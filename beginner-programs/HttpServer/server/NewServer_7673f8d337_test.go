// Test generated by RoostGPT for test roost-test using AI Type Azure Open AI and AI Model roost-gpt4-32k

package server

import (
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	"github.com/gorilla/mux"
)

// TestNewServer test NewServer function
func TestNewServer(t *testing.T) {
	srv := NewServer()
	assert.NotNil(t, srv, "Returned server is nil")
}

// TestCreatedRoutes test the routes are properly created
func TestCreatedRoutes(t *testing.T) {
	tests := []struct {
		route    string
		response string
		status   int
	}{
		{"/hello/John", "Hello John", http.StatusOK},
		{"/dummyurl", "404 page not found\n", http.StatusNotFound},
		{"/", "Hello World", http.StatusOK},
	}

	srv := NewServer().(*mux.Router)

	for _, test := range tests {
		req := httptest.NewRequest("GET", test.route, nil)
		res := httptest.NewRecorder()
		srv.ServeHTTP(res, req)
		if res.Body.String() != test.response || res.Code != test.status {
			t.Errorf("Unexpected output for route %s: got %s (code %d), want %s (code %d)",
				test.route, res.Body.String(), res.Code, test.response, test.status)
		}
	}
}

// TestServerError test server can handle panic error
func TestServerError(t *testing.T) {
	srv := NewServer().(*mux.Router)
	req := httptest.NewRequest("GET", "/panic", nil)
	res := httptest.NewRecorder()
	srv.ServeHTTP(res, req)
	if res.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status code for panic: got %d, want %d", res.Code, http.StatusInternalServerError)
	}
}

// TestConcurrentRequests test server can handle concurrent requests
func TestConcurrentRequests(t *testing.T) {
	srv := NewServer().(*mux.Router)
	var wg sync.WaitGroup
	requests := []struct {
		route    string
		response string
	}{
		{"/hello/John", "Hello John"},
		{"/", "Hello World"},
		{"/hello/Jane", "Hello Jane"},
	}
	
	wg.Add(len(requests))
	for _, req := range requests {
		go func(req struct {
			route    string
			response string
		}) {
			defer wg.Done()
			res := httptest.NewRecorder()
			r := httptest.NewRequest(http.MethodGet, req.route, nil)
			srv.ServeHTTP(res, r)
			if res.Body.String() != req.response || res.Code != http.StatusOK {
				t.Errorf("Unexpected output for route %s: got %s (code %d), want %s (code %d)",
					req.route, res.Body.String(), res.Code, req.response, http.StatusOK)
			}
		}(req)
	}
	wg.Wait()
}
