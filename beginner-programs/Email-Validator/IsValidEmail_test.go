// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-test using AI Type  and AI Model 

ROOST_METHOD_HASH=IsValidEmail_9ebd397bff
ROOST_METHOD_SIG_HASH=IsValidEmail_d2603fb18f

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: learning-go/beginner-programs/Email-Validator/email_test.go
Test Cases:
    [TestIsValidEmail]

Here are several test scenarios for the `IsValidEmail` function, covering various aspects of its functionality:

```
Scenario 1: Valid Email Address

Details:
  Description: This test verifies that a typical, valid email address is correctly identified as valid by the function.
  Execution:
    Arrange: Prepare a valid email address string, e.g., "test@example.com".
    Act: Call the IsValidEmail function with the valid email address.
    Assert: Check that the function returns true.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Valid email addresses conforming to standard patterns should return true. This logic ensures that compliant emails are accepted by the function.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures the application can correctly validate standard user email entries.

Scenario 2: Invalid Email Address - Missing '@'

Details:
  Description: Test the behavior of the function when an email address is missing the '@' symbol, which is critical to a valid format.
  Execution:
    Arrange: Prepare an invalid email, e.g., "testexample.com".
    Act: Invoke IsValidEmail with the invalid email.
    Assert: Verify that the function returns false.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Missing the '@' symbol invalidates standard email format. The scenario checks the function's capacity to reject such inputs.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures malformed emails are not accepted, maintaining data integrity.

Scenario 3: Invalid Email Address - Exceeds Maximum Length

Details:
  Description: Validates the function's ability to reject email addresses that exceed the 255-character length limit.
  Execution:
    Arrange: Create an email string longer than 255 characters.
    Act: Pass this long email to the IsValidEmail method.
    Assert: Confirm that the function responds with false.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Emails exceeding 255 characters could break systems relying on standard email length limits. Hence, they should return false.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Enforces constraints critical for security and compliance with email standards.

Scenario 4: Valid Email Address with Subdomain

Details:
  Description: Tests if the function can handle and validate email addresses containing subdomains correctly.
  Execution:
    Arrange: Use an email such as "user@mail.example.com".
    Act: Input the given email into IsValidEmail.
    Assert: Ensure the function output is true.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Correct formatting of subdomains is essential for identifying complex valid emails.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Supports diverse, valid subdomain structures in emails, enhancing usability.

Scenario 5: Invalid Email Address - Special Characters in Local Part

Details:
  Description: Ensures the function can distinguish email addresses with invalid special characters in the local part (before '@').
  Execution:
    Arrange: Use an email like "test@ex@ample.com".
    Act: Input this invalid string to IsValidEmail.
    Assert: Verify a false is returned.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Special characters placed improperly break RFC standard compliance, rendering the email invalid.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Guards against acceptance of flawed email formats that could affect contact systems.

Scenario 6: Valid Email Address with Plus Alias

Details:
  Description: Check that the function supports valid plus aliasing used in email addresses, which is a common practice.
  Execution:
    Arrange: Provide an email such as "user+alias@example.com".
    Act: Run the IsValidEmail function with this email.
    Assert: Assess whether the result is true.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Plus aliasing is allowed in many email systems and should be accepted.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures compatibility with email systems using aliasing for better user organization and management.
```

These scenarios address both broad and specific aspects of email validation, which are critical to maintaining robust and reliable email handling capabilities in the application.
*/

// ********RoostGPT********
// email.go
package emailvalidator

import (
	"regexp"
)

// Using a consistent email pattern across the codebase for validity checks
const emailPattern = `^\w+@[a-zA-Z_]+\.[a-zA-Z]{2,3}$`

var emailRegexp = regexp.MustCompile(emailPattern)

// IsValidEmail checks if the provided email string is a valid email address.
func IsValidEmail(email string) bool {
	if len(email) > 255 {
		return false
	}
	return emailRegexp.MatchString(email)
}
