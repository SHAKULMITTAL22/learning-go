// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-test using AI Type  and AI Model 

ROOST_METHOD_HASH=IsValidEmail_9ebd397bff
ROOST_METHOD_SIG_HASH=IsValidEmail_d2603fb18f

Here are several test scenarios for the `IsValidEmail` function, based on typical email validation requirements. These scenarios aim to cover various edge cases and normal operations by evaluating different email strings.

### Scenario 1: Valid Email Address

Details:
  - Description: Check that a standard valid email address is correctly identified as valid.
Execution:
  - Arrange: Use a simple, valid email string such as "example@example.com".
  - Act: Call `IsValidEmail` with the valid email.
  - Assert: Verify that the function returns `true`.
Validation:
  - Explain: This asserts that typical email addresses pass the validation, which is crucial for allowing users to register or login.
  - Discuss: It's important because valid emails should be correctly recognized, ensuring users can communicate and receive notifications.

### Scenario 2: Exceeds Maximum Length

Details:
  - Description: Check that an email address exceeding 255 characters is invalid.
Execution:
  - Arrange: Construct an email address string with more than 255 characters.
  - Act: Call `IsValidEmail` with the long email string.
  - Assert: Confirm that the function returns `false`.
Validation:
  - Explain: This ensures the function upholds the maximum length constraint for email addresses.
  - Discuss: It prevents issues in systems where extraordinarily long emails might cause buffer overflows or other errors.

### Scenario 3: Invalid Format (No "@" Symbol)

Details:
  - Description: Check that an email without an "@" symbol is invalid.
Execution:
  - Arrange: Use an invalid email string like "example.com".
  - Act: Call `IsValidEmail` with the invalid email string.
  - Assert: Ensure the function returns `false`.
Validation:
  - Explain: The presence of an "@" symbol is crucial for determining an email's validity.
  - Discuss: This prevents accepting incorrectly formatted email addresses, preserving data integrity.

### Scenario 4: Empty String

Details:
  - Description: Verify that an empty string is rejected as an invalid email.
Execution:
  - Arrange: Use an empty string as the input.
  - Act: Call `IsValidEmail` with the empty string.
  - Assert: Validate that the function returns `false`.
Validation:
  - Explain: An empty string doesn't form a valid email address.
  - Discuss: This test checks input validation, ensuring non-empty emails are entered, which is fundamental for user data entry.

### Scenario 5: Invalid Format (Leading and Trailing Spaces)

Details:
  - Description: Check if leading or trailing spaces in an email make it invalid.
Execution:
  - Arrange: Craft an email string with leading and trailing spaces like "  example@example.com  ".
  - Act: Call `IsValidEmail` with the malformed email.
  - Assert: Confirm the function returns `false`.
Validation:
  - Explain: Spaces should render the email invalid unless trimmed first.
  - Discuss: It ensures the email input is well-formed, avoiding user entry errors.

### Scenario 6: Valid Email with Subdomain

Details:
  - Description: Validate that emails with subdomains are accepted.
Execution:
  - Arrange: Use an email string like "user@mail.example.com".
  - Act: Invoke `IsValidEmail` with the subdomain format email.
  - Assert: Check that the function returns `true`.
Validation:
  - Explain: Subdomains are common in business and educational contexts.
  - Discuss: Recognizing emails with subdomains is crucial to cover a broader range of email formats.

These scenarios comprehensively assess how well `IsValidEmail` handles typical use cases and corner cases, ensuring it performs correctly across a variety of situations essential for the application's functionality.
*/

// ********RoostGPT********
package Validator

import (
	"regexp"
	"testing"
)

var emailPattern = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)

// IsValidEmail checks if the provided email is valid
func IsValidEmail(email string) bool {
	if len(email) > 255 {
		return false
	}
	return emailPattern.MatchString(email)
}

func TestIsValidEmail(t *testing.T) {
	tests := []struct {
		email    string
		expected bool
	}{
		{"test@example.com", true},
		{"invalid-email", false},
		{"test@.com", false},
		{"test@localhost", false},
		{"test@domain.co.uk", true},
		{"", false},
		{"a@b.com", true},
		{"very.long.email.address@example.com", true},
		{"toolongemailtoolongemailtoolongemailtoolongemailtoolongemailtoolongemailtoolongemailtoolongemailtoolongemailtoolongemailtoolongemailtoolongemailtoolongemailtoolongemail@domain.com", false},
	}

	for _, tt := range tests {
		t.Run(tt.email, func(t *testing.T) {
			result := IsValidEmail(tt.email)
			if result != tt.expected {
				t.Errorf("IsValidEmail(%q) = %v; want %v", tt.email, result, tt.expected)
			}
		})
	}
}
