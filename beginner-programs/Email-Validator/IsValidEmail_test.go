// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-test using AI Type  and AI Model 

ROOST_METHOD_HASH=IsValidEmail_9ebd397bff
ROOST_METHOD_SIG_HASH=IsValidEmail_d2603fb18f

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: learning-go/beginner-programs/Email-Validator/email_test.go
Test Cases:
    [TestIsValidEmail]

Scenario 1: Valid Email Test

Details:
    Description: This test checks whether the function "IsValidEmail" correctly identifies valid email addresses.
Execution:
    Arrange: Define a list of valid email addresses. Each email should adhere to the standard email format.
    Act: Iterate through the list of valid emails, calling "IsValidEmail" for each one.
    Assert: Confirm that "IsValidEmail" returns true for all emails in the list.
Validation:
    The function should return true for valid email addresses, explaining why we assert the truth of the function's return value for each valid email. This test is critical for ensuring that users can successfully register or log in with valid email addresses.

Scenario 2: Invalid Email Test

Details:
    Description: This test verifies the function "IsValidEmail" accurately detects invalid email addresses. 
Execution:
    Arrange: Define a list of invalid email addresses. These emails could be malformed or exceed 255 characters in length.
    Act: Run "IsValidEmail" for each invalid email.
    Assert: Assert that "IsValidEmail" returns false for each email.
Validation:
    The function should return false for invalid or non-standard email addresses which is why for every negative scenario we expect the function to be false. This test confirms that the system properly blocks unacceptable email input.

Scenario 3: Empty Email Test

Details:
    Description: This test checks if the function "IsValidEmail" handles empty email strings correctly.
Execution:
    Arrange: Define an empty email string.
    Act: Call "IsValidEmail" on the empty string.
    Assert: Assert that "IsValidEmail" returns false.
Validation:
    An email address cannot be empty; thus, the function should return false. This scenario checks the function's robustness in negative cases and ensures that users cannot proceed without providing an email address.

Scenario 4: Email Length Test

Details:
    Description: This test ensures that the function "IsValidEmail" checks the length of the email and correctly validates it.
Execution:
    Arrange: Generate an email string that is longer than 255 characters.
    Act: Call "IsValidEmail" for the overly long email string.
    Assert: The function should return false.
Validation:
    The rule is that an email should not exceed 255 characters. Hence, the function should return false for any email exceeding this limit. Thus, this test verifies the function's adherence to this rule, ensuring the system properly handles overly long emails.
*/

// ********RoostGPT********
package main

import (
	"fmt"
	"regexp"
	"testing"
)

var emailRegexp = regexp.MustCompile("^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")

func IsValidEmail(email string) bool {
	if len(email) > 255 {
		return false
	}
	return emailRegexp.MatchString(email)
}

func TestIsValidEmail(t *testing.T) {

	tt := []struct {
		email  string
		result bool
	}{
		{"test@test.com", true},
		{"test.test@test.com", true},
		{"test_test@test.com", true},
		{"test+test@test.com", true},
		{"test", false},
		{"@test.com", false},
		{"test@.com", false},
		{"test@test..com", false},
		{"test@test.c", false},
		{"", false},
		{genLongEmail(), false},
	}

	for _, tc := range tt {
		t.Run(fmt.Sprintf("Email: %v, Expected Result: %v", tc.email, tc.result), func(t *testing.T) {
			res := IsValidEmail(tc.email)
			if res != tc.result {
				t.Errorf("Expected %v, but got %v", tc.result, res)
			}
		})
	}
}

func genLongEmail() string {
	var email string
	for i := 0; i < 256; i++ {
		email += "a"
	}
	email += "@test.com"
	return email
}
