// ********RoostGPT********
/*
Test generated by RoostGPT for test go-test using AI Type  and AI Model 

ROOST_METHOD_HASH=IsValidEmail_9ebd397bff
ROOST_METHOD_SIG_HASH=IsValidEmail_d2603fb18f

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: learning-go/beginner-programs/Email-Validator/IsValidEmail_test.go
Test Cases:
    [TestIsValidEmail]

Based on the provided function and existing test cases, here are additional test scenarios for the IsValidEmail function:

Scenario 1: Email with multiple dots in domain

Details:
  Description: Test if an email address with multiple dots in the domain part is considered valid.
Execution:
  Arrange: Prepare an email address with multiple dots in the domain.
  Act: Call IsValidEmail with the prepared email address.
  Assert: Verify that the function returns true.
Validation:
  This test ensures that the function correctly handles valid email addresses with multiple dots in the domain, which are allowed according to email standards.

Scenario 2: Email with special characters in local part

Details:
  Description: Test if an email address with allowed special characters in the local part is considered valid.
Execution:
  Arrange: Prepare an email address with special characters like "!#$%&'*+-/=?^_`{|}~" in the local part.
  Act: Call IsValidEmail with the prepared email address.
  Assert: Verify that the function returns true.
Validation:
  This test ensures that the function correctly handles valid email addresses with special characters in the local part, as per email standards.

Scenario 3: Email with quoted local part

Details:
  Description: Test if an email address with a quoted local part containing spaces and special characters is considered valid.
Execution:
  Arrange: Prepare an email address with a quoted local part, e.g., '"John Doe"@example.com'.
  Act: Call IsValidEmail with the prepared email address.
  Assert: Verify that the function returns true.
Validation:
  This test checks if the function correctly handles quoted local parts in email addresses, which are valid according to email standards.

Scenario 4: Email with IP address as domain

Details:
  Description: Test if an email address using an IP address as the domain is considered valid.
Execution:
  Arrange: Prepare an email address with an IP address as the domain, e.g., 'user@[192.168.0.1]'.
  Act: Call IsValidEmail with the prepared email address.
  Assert: Verify that the function returns true.
Validation:
  This test ensures that the function correctly handles email addresses with IP addresses as domains, which are valid in certain contexts.

Scenario 5: Email with very short local part and domain

Details:
  Description: Test if an email address with minimal length local part and domain is considered valid.
Execution:
  Arrange: Prepare an email address with a single character local part and domain, e.g., 'a@b.c'.
  Act: Call IsValidEmail with the prepared email address.
  Assert: Verify that the function returns true.
Validation:
  This test checks if the function correctly handles valid email addresses with minimal length components, which are technically allowed.

Scenario 6: Email with long local part

Details:
  Description: Test if an email address with a long local part (but still within overall length limits) is considered valid.
Execution:
  Arrange: Prepare an email address with a local part that's close to, but not exceeding, the maximum allowed length.
  Act: Call IsValidEmail with the prepared email address.
  Assert: Verify that the function returns true.
Validation:
  This test ensures that the function correctly handles email addresses with long local parts, as long as the overall length is within limits.

Scenario 7: Email with non-ASCII characters

Details:
  Description: Test if an email address containing non-ASCII characters (e.g., UTF-8) is considered valid.
Execution:
  Arrange: Prepare an email address with non-ASCII characters, e.g., '체ser@ex채mple.com'.
  Act: Call IsValidEmail with the prepared email address.
  Assert: Verify the function's behavior (true or false, depending on the intended support for internationalized email addresses).
Validation:
  This test checks how the function handles internationalized email addresses, which may or may not be supported depending on the implementation.

These scenarios cover additional aspects of email validation that weren't addressed in the existing test cases, including edge cases and less common but valid email formats.
*/

// ********RoostGPT********
// File: is_valid_email_test.go

package validator

import (
	"testing"
)

func TestIsValidEmail(t *testing.T) {
	tests := []struct {
		name  string
		email string
		want  bool
	}{
		{
			name:  "Valid email with multiple dots in domain",
			email: "user@example.co.uk",
			want:  true,
		},
		{
			name:  "Valid email with special characters in local part",
			email: "user!#$%&'*+-/=?^_`{|}~@example.com",
			want:  true,
		},
		{
			name:  "Valid email with quoted local part",
			email: `"John Doe"@example.com`,
			want:  true,
		},
		{
			name:  "Valid email with IP address as domain",
			email: "user@[192.168.0.1]",
			want:  true,
		},
		{
			name:  "Valid email with very short local part and domain",
			email: "a@b.c",
			want:  true,
		},
		{
			name:  "Valid email with long local part",
			email: "verylonglocalparthavingmorethan64characters@example.com",
			want:  true,
		},
		{
			name:  "Invalid email with non-ASCII characters",
			email: "체ser@ex채mple.com",
			want:  false,
		},
		{
			name:  "Invalid email without @",
			email: "userexample.com",
			want:  false,
		},
		{
			name:  "Invalid email with empty local part",
			email: "@example.com",
			want:  false,
		},
		{
			name:  "Invalid email with empty domain",
			email: "user@",
			want:  false,
		},
		{
			name:  "Invalid email exceeding maximum length",
			email: "a" + string(make([]byte, 256)) + "@example.com",
			want:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := IsValidEmail(tt.email)
			if got != tt.want {
				t.Errorf("IsValidEmail(%q) = %v, want %v", tt.email, got, tt.want)
			}
		})
	}
}
