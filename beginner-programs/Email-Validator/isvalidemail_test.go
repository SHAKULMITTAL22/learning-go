// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-1 using AI Type  and AI Model 

ROOST_METHOD_HASH=IsValidEmail_9ebd397bff
ROOST_METHOD_SIG_HASH=IsValidEmail_d2603fb18f

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: learning-go/beginner-programs/Email-Validator/IsValidEmail_test.go
Test Cases:
    [TestIsValidEmail]

Based on the provided function and existing tests, I'll generate additional test scenarios for the `IsValidEmail` function. Here are some new test scenarios that cover different aspects and edge cases:

Scenario 1: Test with a valid email containing multiple dots in the domain

Details:
  Description: This test checks if the function correctly validates an email address with multiple dots in the domain part.
Execution:
  Arrange: Prepare a valid email address with multiple dots in the domain.
  Act: Call IsValidEmail with the prepared email address.
  Assert: Verify that the function returns true.
Validation:
  This test ensures that the function correctly handles valid email addresses with complex domain structures, which are becoming increasingly common.

Scenario 2: Test with an email containing special characters in the local part

Details:
  Description: This test verifies if the function correctly validates an email address containing allowed special characters in the local part.
Execution:
  Arrange: Prepare an email address with special characters like "!#$%&'*+-/=?^_`{|}~" in the local part.
  Act: Call IsValidEmail with the prepared email address.
  Assert: Verify that the function returns true.
Validation:
  This test ensures that the function correctly handles valid email addresses with special characters as per RFC 5322.

Scenario 3: Test with an email containing Unicode characters

Details:
  Description: This test checks if the function correctly handles email addresses containing Unicode characters.
Execution:
  Arrange: Prepare an email address with Unicode characters in both local and domain parts.
  Act: Call IsValidEmail with the prepared email address.
  Assert: Verify that the function returns the expected result based on the implementation's support for Unicode.
Validation:
  This test helps determine if the function supports internationalized email addresses, which is important for global applications.

Scenario 4: Test with an email containing a quoted local part

Details:
  Description: This test verifies if the function correctly validates an email address with a quoted local part containing special characters.
Execution:
  Arrange: Prepare an email address with a quoted local part containing spaces and special characters.
  Act: Call IsValidEmail with the prepared email address.
  Assert: Verify that the function returns the expected result based on the implementation's support for quoted local parts.
Validation:
  This test ensures that the function correctly handles more complex, but still valid, email formats as per RFC 5322.

Scenario 5: Test with an email containing comments

Details:
  Description: This test checks if the function correctly handles email addresses containing comments in parentheses.
Execution:
  Arrange: Prepare an email address with comments in the local part and/or domain part.
  Act: Call IsValidEmail with the prepared email address.
  Assert: Verify that the function returns the expected result based on the implementation's handling of comments.
Validation:
  This test helps determine how the function deals with less common, but still valid, email formats that include comments.

Scenario 6: Test with an email containing a long local part

Details:
  Description: This test verifies if the function correctly handles an email address with a local part approaching the maximum allowed length.
Execution:
  Arrange: Prepare an email address with a local part that is 64 characters long (the maximum allowed length).
  Act: Call IsValidEmail with the prepared email address.
  Assert: Verify that the function returns true.
Validation:
  This test ensures that the function correctly handles email addresses with long local parts without incorrectly rejecting them.

Scenario 7: Test with an email containing a plus sign for subaddressing

Details:
  Description: This test checks if the function correctly validates an email address using the plus sign for subaddressing.
Execution:
  Arrange: Prepare an email address using the plus sign for subaddressing (e.g., "user+tag@example.com").
  Act: Call IsValidEmail with the prepared email address.
  Assert: Verify that the function returns true.
Validation:
  This test ensures that the function correctly handles a common email format used for filtering and organizing emails.

These additional test scenarios cover various aspects of email validation that weren't explicitly covered in the existing tests. They help ensure that the `IsValidEmail` function handles a wide range of valid and invalid email formats correctly.
*/

// ********RoostGPT********
package validator

import (
	"testing"
)

func TestIsValidEmail(t *testing.T) {
	tests := []struct {
		name  string
		email string
		want  bool
	}{
		{
			name:  "Valid email with multiple dots in domain",
			email: "user@sub.domain.example.com",
			want:  true,
		},
		{
			name:  "Valid email with special characters in local part",
			email: "user!#$%&'*+-/=?^_`{|}~@example.com",
			want:  true,
		},
		{
			name:  "Email with Unicode characters",
			email: "üser@exämple.com",
			want:  false, // Assuming the current implementation doesn't support Unicode
		},
		{
			name:  "Email with quoted local part",
			email: "\"user name\"@example.com",
			want:  false, // Assuming the current implementation doesn't support quoted local parts
		},
		{
			name:  "Email with comments",
			email: "user(comment)@example.com",
			want:  false, // Assuming the current implementation doesn't support comments
		},
		{
			name:  "Email with long local part",
			email: "abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789@example.com",
			want:  true,
		},
		{
			name:  "Email with plus sign for subaddressing",
			email: "user+tag@example.com",
			want:  true,
		},
		// Additional test cases
		{
			name:  "Invalid email without @",
			email: "userexample.com",
			want:  false,
		},
		{
			name:  "Invalid email with multiple @",
			email: "user@example@com",
			want:  false,
		},
		{
			name:  "Invalid email with empty local part",
			email: "@example.com",
			want:  false,
		},
		{
			name:  "Invalid email with empty domain",
			email: "user@",
			want:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := IsValidEmail(tt.email)
			if got != tt.want {
				t.Errorf("IsValidEmail(%q) = %v, want %v", tt.email, got, tt.want)
			}
		})
	}
}
