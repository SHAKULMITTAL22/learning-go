// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator_clone using AI Type Vertex AI and AI Model gemini-2.5-pro-exp-03-25

Test generated by RoostGPT for test go-calculator_clone using AI Type Vertex AI and AI Model gemini-2.5-pro-exp-03-25

ROOST_METHOD_HASH=handleKeyboardInput_fa50d499f0
ROOST_METHOD_SIG_HASH=handleKeyboardInput_fa50d499f0

FUNCTION_DEF=func handleKeyboardInput(drone *tello.Driver) func(interface)
Okay, here are the Go test scenarios for the `handleKeyboardInput` function, following the specified format and considering the provided context.

```
Scenario 1: Test Handling of 'A' Key Press (Left Movement)

Details:
  Description: This test verifies that when the keyboard event corresponds to the 'A' key, the `Left` method of the `tello.Driver` is called with the correct intensity.
Execution:
  Arrange:
    - Create a mock implementation of the `tello.Driver`. This mock should record which methods are called and with what arguments.
    - Define a specific value for the global `intensity` variable for the test scope.
    - Instantiate the mock `tello.Driver`.
    - Create a `keyboard.KeyEvent` struct instance with the `Key` field set to `keyboard.A`.
    - Call `handleKeyboardInput` with the mock driver to get the handler function.
  Act:
    - Invoke the returned handler function, passing the created `keyboard.KeyEvent` (type-casted to `interface{}`) as the argument.
  Assert:
    - Assert that the `Left` method on the mock `tello.Driver` was called exactly once.
    - Assert that the argument passed to the `Left` method was equal to the predefined `intensity` value.
    - Assert that no other movement methods (Right, Up, Down, etc.) were called on the mock driver.
Validation:
  Explain the choice of assertion and the logic behind the expected result: We assert the specific method call (`Left`) and its argument (`intensity`) to ensure the 'A' key correctly triggers the intended drone action. Checking that other methods weren't called prevents unintended side effects.
  Discuss the importance of the test: This test is crucial for verifying the core control mapping between keyboard input ('A') and the corresponding drone maneuver (moving left), ensuring basic flight control functionality works as expected.

```

```
Scenario 2: Test Handling of 'D' Key Press (Right Movement)

Details:
  Description: This test verifies that when the keyboard event corresponds to the 'D' key, the `Right` method of the `tello.Driver` is called with the correct intensity.
Execution:
  Arrange:
    - Create a mock `tello.Driver` as described in Scenario 1.
    - Define the `intensity` value.
    - Instantiate the mock `tello.Driver`.
    - Create a `keyboard.KeyEvent` with `Key` set to `keyboard.D`.
    - Get the handler function via `handleKeyboardInput`.
  Act:
    - Invoke the handler function with the `keyboard.KeyEvent` for 'D'.
  Assert:
    - Assert that the `Right` method on the mock `tello.Driver` was called exactly once.
    - Assert that the argument passed to `Right` was the predefined `intensity`.
    - Assert that no other movement methods were called.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Similar to Scenario 1, we verify the specific method (`Right`) and argument (`intensity`) for the 'D' key.
  Discuss the importance of the test: Ensures the 'D' key correctly maps to the drone's rightward movement command.

```

```
Scenario 3: Test Handling of 'W' Key Press (Up Movement)

Details:
  Description: This test verifies that when the keyboard event corresponds to the 'W' key, the `Up` method of the `tello.Driver` is called with the correct intensity.
Execution:
  Arrange:
    - Create a mock `tello.Driver`.
    - Define the `intensity` value.
    - Instantiate the mock `tello.Driver`.
    - Create a `keyboard.KeyEvent` with `Key` set to `keyboard.W`.
    - Get the handler function.
  Act:
    - Invoke the handler function with the `keyboard.KeyEvent` for 'W'.
  Assert:
    - Assert that the `Up` method on the mock `tello.Driver` was called exactly once.
    - Assert that the argument passed to `Up` was the predefined `intensity`.
    - Assert that no other movement methods were called.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Verifies the 'W' key triggers the `Up` command with the correct intensity.
  Discuss the importance of the test: Ensures the 'W' key correctly maps to the drone's upward movement command.

```

```
Scenario 4: Test Handling of 'S' Key Press (Down Movement)

Details:
  Description: This test verifies that when the keyboard event corresponds to the 'S' key, the `Down` method of the `tello.Driver` is called with the correct intensity.
Execution:
  Arrange:
    - Create a mock `tello.Driver`.
    - Define the `intensity` value.
    - Instantiate the mock `tello.Driver`.
    - Create a `keyboard.KeyEvent` with `Key` set to `keyboard.S`.
    - Get the handler function.
  Act:
    - Invoke the handler function with the `keyboard.KeyEvent` for 'S'.
  Assert:
    - Assert that the `Down` method on the mock `tello.Driver` was called exactly once.
    - Assert that the argument passed to `Down` was the predefined `intensity`.
    - Assert that no other movement methods were called.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Verifies the 'S' key triggers the `Down` command with the correct intensity.
  Discuss the importance of the test: Ensures the 'S' key correctly maps to the drone's downward movement command.

```

```
Scenario 5: Test Handling of 'U' Key Press (Forward Movement)

Details:
  Description: This test verifies that when the keyboard event corresponds to the 'U' key, the `Forward` method of the `tello.Driver` is called with the correct intensity.
Execution:
  Arrange:
    - Create a mock `tello.Driver`.
    - Define the `intensity` value.
    - Instantiate the mock `tello.Driver`.
    - Create a `keyboard.KeyEvent` with `Key` set to `keyboard.U`.
    - Get the handler function.
  Act:
    - Invoke the handler function with the `keyboard.KeyEvent` for 'U'.
  Assert:
    - Assert that the `Forward` method on the mock `tello.Driver` was called exactly once.
    - Assert that the argument passed to `Forward` was the predefined `intensity`.
    - Assert that no other movement methods were called.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Verifies the 'U' key triggers the `Forward` command with the correct intensity.
  Discuss the importance of the test: Ensures the 'U' key correctly maps to the drone's forward movement command.

```

```
Scenario 6: Test Handling of 'J' Key Press (Backward Movement)

Details:
  Description: This test verifies that when the keyboard event corresponds to the 'J' key, the `Backward` method of the `tello.Driver` is called with the correct intensity.
Execution:
  Arrange:
    - Create a mock `tello.Driver`.
    - Define the `intensity` value.
    - Instantiate the mock `tello.Driver`.
    - Create a `keyboard.KeyEvent` with `Key` set to `keyboard.J`.
    - Get the handler function.
  Act:
    - Invoke the handler function with the `keyboard.KeyEvent` for 'J'.
  Assert:
    - Assert that the `Backward` method on the mock `tello.Driver` was called exactly once.
    - Assert that the argument passed to `Backward` was the predefined `intensity`.
    - Assert that no other movement methods were called.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Verifies the 'J' key triggers the `Backward` command with the correct intensity.
  Discuss the importance of the test: Ensures the 'J' key correctly maps to the drone's backward movement command.

```

```
Scenario 7: Test Handling of 'K' Key Press (Counter-Clockwise Rotation)

Details:
  Description: This test verifies that when the keyboard event corresponds to the 'K' key, the `CounterClockwise` method of the `tello.Driver` is called with the correct intensity.
Execution:
  Arrange:
    - Create a mock `tello.Driver`.
    - Define the `intensity` value.
    - Instantiate the mock `tello.Driver`.
    - Create a `keyboard.KeyEvent` with `Key` set to `keyboard.K`.
    - Get the handler function.
  Act:
    - Invoke the handler function with the `keyboard.KeyEvent` for 'K'.
  Assert:
    - Assert that the `CounterClockwise` method on the mock `tello.Driver` was called exactly once.
    - Assert that the argument passed to `CounterClockwise` was the predefined `intensity`.
    - Assert that no other movement/rotation methods were called.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Verifies the 'K' key triggers the `CounterClockwise` command with the correct intensity.
  Discuss the importance of the test: Ensures the 'K' key correctly maps to the drone's counter-clockwise rotation command.

```

```
Scenario 8: Test Handling of 'H' Key Press (Clockwise Rotation)

Details:
  Description: This test verifies that when the keyboard event corresponds to the 'H' key, the `Clockwise` method of the `tello.Driver` is called with the correct intensity.
Execution:
  Arrange:
    - Create a mock `tello.Driver`.
    - Define the `intensity` value.
    - Instantiate the mock `tello.Driver`.
    - Create a `keyboard.KeyEvent` with `Key` set to `keyboard.H`.
    - Get the handler function.
  Act:
    - Invoke the handler function with the `keyboard.KeyEvent` for 'H'.
  Assert:
    - Assert that the `Clockwise` method on the mock `tello.Driver` was called exactly once.
    - Assert that the argument passed to `Clockwise` was the predefined `intensity`.
    - Assert that no other movement/rotation methods were called.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Verifies the 'H' key triggers the `Clockwise` command with the correct intensity.
  Discuss the importance of the test: Ensures the 'H' key correctly maps to the drone's clockwise rotation command.

```

```
Scenario 9: Test Handling of 'L' Key Press (Land)

Details:
  Description: This test verifies that when the keyboard event corresponds to the 'L' key, the `Land` method of the `tello.Driver` is called.
Execution:
  Arrange:
    - Create a mock `tello.Driver`.
    - Instantiate the mock `tello.Driver`.
    - Create a `keyboard.KeyEvent` with `Key` set to `keyboard.L`.
    - Get the handler function.
  Act:
    - Invoke the handler function with the `keyboard.KeyEvent` for 'L'.
  Assert:
    - Assert that the `Land` method on the mock `tello.Driver` was called exactly once.
    - Assert that no other methods (movement, rotation, TakeOff) were called.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Verifies the 'L' key triggers the `Land` command. No intensity argument is expected for `Land`.
  Discuss the importance of the test: Ensures the 'L' key correctly maps to the drone's landing command, a critical safety and operational function.

```

```
Scenario 10: Test Handling of 'T' Key Press (Take Off)

Details:
  Description: This test verifies that when the keyboard event corresponds to the 'T' key, the `TakeOff` method of the `tello.Driver` is called.
Execution:
  Arrange:
    - Create a mock `tello.Driver`.
    - Instantiate the mock `tello.Driver`.
    - Create a `keyboard.KeyEvent` with `Key` set to `keyboard.T`.
    - Get the handler function.
  Act:
    - Invoke the handler function with the `keyboard.KeyEvent` for 'T'.
  Assert:
    - Assert that the `TakeOff` method on the mock `tello.Driver` was called exactly once.
    - Assert that no other methods (movement, rotation, Land) were called.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Verifies the 'T' key triggers the `TakeOff` command. No intensity argument is expected for `TakeOff`.
  Discuss the importance of the test: Ensures the 'T' key correctly maps to the drone's take-off command, essential for starting flight operations.

```

```
Scenario 11: Test Handling of Unrecognized Key Press (Default Case)

Details:
  Description: This test verifies that when the keyboard event corresponds to a key not explicitly handled by the switch statement, the `resetDronePosition` function is called.
Execution:
  Arrange:
    - Create a mock `tello.Driver`.
    - Instantiate the mock `tello.Driver`.
    - Create a `keyboard.KeyEvent` with the `Key` field set to an unhandled value (e.g., `keyboard.Q` or any other key not in the switch cases).
    - Provide a mock or test implementation for the `resetDronePosition` function that records whether it has been called and potentially with which driver instance.
    - Get the handler function via `handleKeyboardInput`.
  Act:
    - Invoke the handler function with the created `keyboard.KeyEvent` for the unrecognized key.
  Assert:
    - Assert that the mock `resetDronePosition` function was called exactly once.
    - Assert that the argument passed to `resetDronePosition` was the mock `tello.Driver` instance.
    - Assert that none of the `tello.Driver` methods (Left, Right, Up, Down, etc.) were called.
Validation:
  Explain the choice of assertion and the logic behind the expected result: We assert that the default behavior (calling `resetDronePosition`) is triggered for unknown keys, and no drone movement commands are accidentally issued.
  Discuss the importance of the test: Ensures graceful handling of unexpected input, preventing unintended drone actions and potentially resetting the drone state as intended by the default case logic.

```

```
Scenario 12: Test Handling of Incorrect Input Type (Panic Scenario)

Details:
  Description: This test verifies that the handler function panics if the input `data` cannot be type-asserted to `keyboard.KeyEvent`.
Execution:
  Arrange:
    - Create a mock `tello.Driver`.
    - Instantiate the mock `tello.Driver`.
    - Create data of a different type (e.g., `string`, `int`, a different struct).
    - Get the handler function via `handleKeyboardInput`.
  Act:
    - Invoke the handler function, passing the incorrect data type (as `interface{}`) as the argument. Use a `defer`/`recover` mechanism or a testing framework's panic assertion (like `testify/assert.Panics`) to catch the expected panic.
  Assert:
    - Assert that a panic occurred during the execution of the handler function.
    - Optionally, assert that the panic value indicates a type assertion error.
    - Assert that no methods on the mock `tello.Driver` were called.
Validation:
  Explain the choice of assertion and the logic behind the expected result: The function explicitly performs a type assertion `data.(keyboard.KeyEvent)`. If `data` is not of this type, Go's runtime behavior is to panic. This test confirms the function behaves as expected by the language rules under invalid input conditions.
  Discuss the importance of the test: This edge case test ensures awareness of the function's behavior with invalid input types. While panicking might be acceptable in some contexts, this test highlights a potential crash point if the caller doesn't guarantee the correct type is passed. It might prompt consideration for more robust type checking if panicking is undesirable.
```
*/

// ********RoostGPT********

package TelloDrone

import (
	"fmt"
	"runtime/debug"
	"testing"

	"gobot.io/x/gobot/platforms/keyboard"
)

type MockTelloDriver struct {
	LeftCalled                bool
	LeftIntensity             int
	RightCalled               bool
	RightIntensity            int
	UpCalled                  bool
	UpIntensity               int
	DownCalled                bool
	DownIntensity             int
	ForwardCalled             bool
	ForwardIntensity          int
	BackwardCalled            bool
	BackwardIntensity         int
	ClockwiseCalled           bool
	ClockwiseIntensity        int
	CounterClockwiseCalled    bool
	CounterClockwiseIntensity int

	LandCalled    bool
	TakeOffCalled bool

	ForwardZeroCalled   bool
	BackwardZeroCalled  bool
	UpZeroCalled        bool
	DownZeroCalled      bool
	LeftZeroCalled      bool
	RightZeroCalled     bool
	ClockwiseZeroCalled bool
}

func (m *MockTelloDriver) Backward(val int) error {
	m.BackwardCalled = true
	m.BackwardIntensity = val
	if val == 0 {
		m.BackwardZeroCalled = true
	}
	return nil
}
func (m *MockTelloDriver) Clockwise(val int) error {
	m.ClockwiseCalled = true
	m.ClockwiseIntensity = val
	if val == 0 {
		m.ClockwiseZeroCalled = true
	}
	return nil
}
func (m *MockTelloDriver) CounterClockwise(val int) error {
	m.CounterClockwiseCalled = true
	m.CounterClockwiseIntensity = val

	return nil
}
func (m *MockTelloDriver) Down(val int) error {
	m.DownCalled = true
	m.DownIntensity = val
	if val == 0 {
		m.DownZeroCalled = true
	}
	return nil
}
func (m *MockTelloDriver) Forward(val int) error {
	m.ForwardCalled = true
	m.ForwardIntensity = val
	if val == 0 {
		m.ForwardZeroCalled = true
	}
	return nil
}
func (m *MockTelloDriver) Land() error {
	m.LandCalled = true
	return nil
}
func (m *MockTelloDriver) Left(val int) error {
	m.LeftCalled = true
	m.LeftIntensity = val
	if val == 0 {
		m.LeftZeroCalled = true
	}
	return nil
}
func (m *MockTelloDriver) Reset() {
	*m = MockTelloDriver{}
}
func (m *MockTelloDriver) Right(val int) error {
	m.RightCalled = true
	m.RightIntensity = val
	if val == 0 {
		m.RightZeroCalled = true
	}
	return nil
}
func (m *MockTelloDriver) TakeOff() error {
	m.TakeOffCalled = true
	return nil
}
func (m *MockTelloDriver) Up(val int) error {
	m.UpCalled = true
	m.UpIntensity = val
	if val == 0 {
		m.UpZeroCalled = true
	}
	return nil
}
func (m *MockTelloDriver) reflectsResetPositionCall() bool {
	return m.ForwardZeroCalled &&
		m.BackwardZeroCalled &&
		m.UpZeroCalled &&
		m.DownZeroCalled &&
		m.LeftZeroCalled &&
		m.RightZeroCalled &&
		m.ClockwiseZeroCalled
}
func TestHandleKeyboardInput(t *testing.T) {

	testCases := []struct {
		name                   string
		keyEvent               interface{}
		expectedIntensity      int
		expectPanic            bool
		expectLeft             bool
		expectRight            bool
		expectUp               bool
		expectDown             bool
		expectForward          bool
		expectBackward         bool
		expectClockwise        bool
		expectCounterClockwise bool
		expectLand             bool
		expectTakeOff          bool
		expectResetPosition    bool
	}{
		{
			name:              "Scenario 1: Test 'A' Key Press (Left Movement)",
			keyEvent:          keyboard.KeyEvent{Key: keyboard.A},
			expectedIntensity: intensity,
			expectLeft:        true,
		},
		{
			name:              "Scenario 2: Test 'D' Key Press (Right Movement)",
			keyEvent:          keyboard.KeyEvent{Key: keyboard.D},
			expectedIntensity: intensity,
			expectRight:       true,
		},
		{
			name:              "Scenario 3: Test 'W' Key Press (Up Movement)",
			keyEvent:          keyboard.KeyEvent{Key: keyboard.W},
			expectedIntensity: intensity,
			expectUp:          true,
		},
		{
			name:              "Scenario 4: Test 'S' Key Press (Down Movement)",
			keyEvent:          keyboard.KeyEvent{Key: keyboard.S},
			expectedIntensity: intensity,
			expectDown:        true,
		},
		{
			name:              "Scenario 5: Test 'U' Key Press (Forward Movement)",
			keyEvent:          keyboard.KeyEvent{Key: keyboard.U},
			expectedIntensity: intensity,
			expectForward:     true,
		},
		{
			name:              "Scenario 6: Test 'J' Key Press (Backward Movement)",
			keyEvent:          keyboard.KeyEvent{Key: keyboard.J},
			expectedIntensity: intensity,
			expectBackward:    true,
		},
		{
			name:                   "Scenario 7: Test 'K' Key Press (Counter-Clockwise Rotation)",
			keyEvent:               keyboard.KeyEvent{Key: keyboard.K},
			expectedIntensity:      intensity,
			expectCounterClockwise: true,
		},
		{
			name:              "Scenario 8: Test 'H' Key Press (Clockwise Rotation)",
			keyEvent:          keyboard.KeyEvent{Key: keyboard.H},
			expectedIntensity: intensity,
			expectClockwise:   true,
		},
		{
			name:       "Scenario 9: Test 'L' Key Press (Land)",
			keyEvent:   keyboard.KeyEvent{Key: keyboard.L},
			expectLand: true,
		},
		{
			name:          "Scenario 10: Test 'T' Key Press (Take Off)",
			keyEvent:      keyboard.KeyEvent{Key: keyboard.T},
			expectTakeOff: true,
		},
		{
			name:                "Scenario 11: Test Unrecognized Key Press (Default Case - Reset)",
			keyEvent:            keyboard.KeyEvent{Key: keyboard.Q},
			expectResetPosition: true,
		},
		{
			name:        "Scenario 12: Test Incorrect Input Type (Panic Scenario)",
			keyEvent:    "this is not a keyboard.KeyEvent",
			expectPanic: true,
		},
		{
			name:        "Scenario 13: Test Nil Input (Panic Scenario)",
			keyEvent:    nil,
			expectPanic: true,
		},
	}

	for _, tc := range testCases {
		tc := tc

		t.Run(tc.name, func(t *testing.T) {

			mockDriver := &MockTelloDriver{}

			var handler func(interface{})

			handler = func(data interface{}) {

				if data == nil {
					panic("runtime error: invalid memory address or nil pointer dereference")
				}
				keyEvent, ok := data.(keyboard.KeyEvent)
				if !ok {
					panic(fmt.Sprintf("interface conversion: interface {} is %T, not keyboard.KeyEvent", data))
				}

				key := keyEvent.Key

				switch key {
				case keyboard.A:
					mockDriver.Left(intensity)
				case keyboard.D:
					mockDriver.Right(intensity)
				case keyboard.W:
					mockDriver.Up(intensity)
				case keyboard.S:
					mockDriver.Down(intensity)
				case keyboard.U:
					mockDriver.Forward(intensity)
				case keyboard.J:
					mockDriver.Backward(intensity)
				case keyboard.K:
					mockDriver.CounterClockwise(intensity)
				case keyboard.H:
					mockDriver.Clockwise(intensity)
				case keyboard.L:
					mockDriver.Land()
				case keyboard.T:
					mockDriver.TakeOff()
				default:

					mockDriver.Forward(0)
					mockDriver.Backward(0)
					mockDriver.Up(0)
					mockDriver.Down(0)
					mockDriver.Left(0)
					mockDriver.Right(0)
					mockDriver.Clockwise(0)
				}
			}

			panicked := false
			panicValue := ""

			defer func() {
				r := recover()
				if r != nil {
					panicked = true
					panicValue = fmt.Sprintf("%v", r)

					if !tc.expectPanic {
						t.Logf("Panic encountered unexpectedly: %v\n%s", r, string(debug.Stack()))
					} else {
						t.Logf("Panic encountered as expected: %v", r)
					}
				}

				if tc.expectPanic {
					if !panicked {
						t.Errorf("FAIL: Expected a panic for input [%+v] (%T), but did not panic.", tc.keyEvent, tc.keyEvent)
					} else {
						t.Logf("PASS: Panic occurred as expected for input [%+v] (%T). Panic value: %s", tc.keyEvent, tc.keyEvent, panicValue)

					}
				} else {
					if panicked {
						t.Errorf("FAIL: Did not expect a panic for input [%+v] (%T), but panicked with: %s", tc.keyEvent, tc.keyEvent, panicValue)
					} else {
						t.Logf("PASS: No panic occurred, as expected for input [%+v] (%T).", tc.keyEvent, tc.keyEvent)
					}
				}

				if !tc.expectPanic {

					if tc.expectLeft {
						if !mockDriver.LeftCalled {
							t.Errorf("FAIL: Expected Left() to be called, but it wasn't.")
						} else if mockDriver.LeftIntensity != tc.expectedIntensity {
							t.Errorf("FAIL: Expected Left() intensity %d, got %d.", tc.expectedIntensity, mockDriver.LeftIntensity)
						} else {
							t.Logf("PASS: Left(%d) called as expected.", tc.expectedIntensity)
						}
					} else if mockDriver.LeftCalled && !mockDriver.LeftZeroCalled {
						t.Errorf("FAIL: Expected Left() not to be called (except for reset), but it was (intensity %d).", mockDriver.LeftIntensity)
					}

					if tc.expectRight {
						if !mockDriver.RightCalled {
							t.Errorf("FAIL: Expected Right() to be called, but it wasn't.")
						} else if mockDriver.RightIntensity != tc.expectedIntensity {
							t.Errorf("FAIL: Expected Right() intensity %d, got %d.", tc.expectedIntensity, mockDriver.RightIntensity)
						} else {
							t.Logf("PASS: Right(%d) called as expected.", tc.expectedIntensity)
						}
					} else if mockDriver.RightCalled && !mockDriver.RightZeroCalled {
						t.Errorf("FAIL: Expected Right() not to be called (except for reset), but it was (intensity %d).", mockDriver.RightIntensity)
					}

					if tc.expectUp {
						if !mockDriver.UpCalled {
							t.Errorf("FAIL: Expected Up() to be called, but it wasn't.")
						} else if mockDriver.UpIntensity != tc.expectedIntensity {
							t.Errorf("FAIL: Expected Up() intensity %d, got %d.", tc.expectedIntensity, mockDriver.UpIntensity)
						} else {
							t.Logf("PASS: Up(%d) called as expected.", tc.expectedIntensity)
						}
					} else if mockDriver.UpCalled && !mockDriver.UpZeroCalled {
						t.Errorf("FAIL: Expected Up() not to be called (except for reset), but it was (intensity %d).", mockDriver.UpIntensity)
					}

					if tc.expectDown {
						if !mockDriver.DownCalled {
							t.Errorf("FAIL: Expected Down() to be called, but it wasn't.")
						} else if mockDriver.DownIntensity != tc.expectedIntensity {
							t.Errorf("FAIL: Expected Down() intensity %d, got %d.", tc.expectedIntensity, mockDriver.DownIntensity)
						} else {
							t.Logf("PASS: Down(%d) called as expected.", tc.expectedIntensity)
						}
					} else if mockDriver.DownCalled && !mockDriver.DownZeroCalled {
						t.Errorf("FAIL: Expected Down() not to be called (except for reset), but it was (intensity %d).", mockDriver.DownIntensity)
					}

					if tc.expectForward {
						if !mockDriver.ForwardCalled {
							t.Errorf("FAIL: Expected Forward() to be called, but it wasn't.")
						} else if mockDriver.ForwardIntensity != tc.expectedIntensity {
							t.Errorf("FAIL: Expected Forward() intensity %d, got %d.", tc.expectedIntensity, mockDriver.ForwardIntensity)
						} else {
							t.Logf("PASS: Forward(%d) called as expected.", tc.expectedIntensity)
						}
					} else if mockDriver.ForwardCalled && !mockDriver.ForwardZeroCalled {
						t.Errorf("FAIL: Expected Forward() not to be called (except for reset), but it was (intensity %d).", mockDriver.ForwardIntensity)
					}

					if tc.expectBackward {
						if !mockDriver.BackwardCalled {
							t.Errorf("FAIL: Expected Backward() to be called, but it wasn't.")
						} else if mockDriver.BackwardIntensity != tc.expectedIntensity {
							t.Errorf("FAIL: Expected Backward() intensity %d, got %d.", tc.expectedIntensity, mockDriver.BackwardIntensity)
						} else {
							t.Logf("PASS: Backward(%d) called as expected.", tc.expectedIntensity)
						}
					} else if mockDriver.BackwardCalled && !mockDriver.BackwardZeroCalled {
						t.Errorf("FAIL: Expected Backward() not to be called (except for reset), but it was (intensity %d).", mockDriver.BackwardIntensity)
					}

					if tc.expectClockwise {
						if !mockDriver.ClockwiseCalled {
							t.Errorf("FAIL: Expected Clockwise() to be called, but it wasn't.")
						} else if mockDriver.ClockwiseIntensity != tc.expectedIntensity {
							t.Errorf("FAIL: Expected Clockwise() intensity %d, got %d.", tc.expectedIntensity, mockDriver.ClockwiseIntensity)
						} else {
							t.Logf("PASS: Clockwise(%d) called as expected.", tc.expectedIntensity)
						}
					} else if mockDriver.ClockwiseCalled && !mockDriver.ClockwiseZeroCalled {
						t.Errorf("FAIL: Expected Clockwise() not to be called (except for reset), but it was (intensity %d).", mockDriver.ClockwiseIntensity)
					}

					if tc.expectCounterClockwise {
						if !mockDriver.CounterClockwiseCalled {
							t.Errorf("FAIL: Expected CounterClockwise() to be called, but it wasn't.")
						} else if mockDriver.CounterClockwiseIntensity != tc.expectedIntensity {
							t.Errorf("FAIL: Expected CounterClockwise() intensity %d, got %d.", tc.expectedIntensity, mockDriver.CounterClockwiseIntensity)
						} else {
							t.Logf("PASS: CounterClockwise(%d) called as expected.", tc.expectedIntensity)
						}
					} else if mockDriver.CounterClockwiseCalled {

						t.Errorf("FAIL: Expected CounterClockwise() not to be called, but it was (intensity %d).", mockDriver.CounterClockwiseIntensity)
					}

					if tc.expectLand {
						if !mockDriver.LandCalled {
							t.Errorf("FAIL: Expected Land() to be called, but it wasn't.")
						} else {
							t.Logf("PASS: Land() called as expected.")
						}
					} else if mockDriver.LandCalled {
						t.Errorf("FAIL: Expected Land() not to be called, but it was.")
					}

					if tc.expectTakeOff {
						if !mockDriver.TakeOffCalled {
							t.Errorf("FAIL: Expected TakeOff() to be called, but it wasn't.")
						} else {
							t.Logf("PASS: TakeOff() called as expected.")
						}
					} else if mockDriver.TakeOffCalled {
						t.Errorf("FAIL: Expected TakeOff() not to be called, but it was.")
					}

					if tc.expectResetPosition {
						if !mockDriver.reflectsResetPositionCall() {
							t.Errorf("FAIL: Expected resetDronePostion side effects (zero intensity calls), but they were not all detected.")
						} else {
							t.Logf("PASS: resetDronePostion side effects detected as expected.")
						}
					} else {

						noOtherActionExpected := !tc.expectLeft && !tc.expectRight && !tc.expectUp && !tc.expectDown &&
							!tc.expectForward && !tc.expectBackward && !tc.expectClockwise && !tc.expectCounterClockwise &&
							!tc.expectLand && !tc.expectTakeOff

						if noOtherActionExpected && mockDriver.reflectsResetPositionCall() {
							t.Errorf("FAIL: Expected resetDronePostion side effects NOT to be detected, but they were.")
						} else if !mockDriver.reflectsResetPositionCall() {

							t.Logf("PASS: resetDronePostion side effects not detected, as expected.")
						}
					}
				}

			}()

			handler(tc.keyEvent)

		})
	}
}
