// ********RoostGPT********
/*
Test generated by RoostGPT for test go-calculator_clone using AI Type Vertex AI and AI Model gemini-2.5-pro-exp-03-25

Test generated by RoostGPT for test go-calculator_clone using AI Type Vertex AI and AI Model gemini-2.5-pro-exp-03-25

ROOST_METHOD_HASH=handleKeyboardInput_fa50d499f0
ROOST_METHOD_SIG_HASH=handleKeyboardInput_fa50d499f0

FUNCTION_DEF=func handleKeyboardInput(drone *tello.Driver) func(interface)
Okay, here are the test scenarios for the `handleKeyboardInput` function in the specified format. These scenarios focus on *what* to test, assuming the use of mocks or test doubles for dependencies like the `tello.Driver`.

---

```
Scenario 1: Test 'A' Key Press Triggers Left Movement

Details:
  Description: This test verifies that when the keyboard event handler receives a 'KeyEvent' with the 'Key' field set to 'keyboard.A', it correctly calls the 'Left' method on the provided 'tello.Driver' instance with the predefined 'intensity'. It also checks that the corresponding informational message is printed.
Execution:
  Arrange:
    - Create a mock implementation of the `tello.Driver`. This mock should record method calls and arguments.
    - Define a test value for the package-level variable `intensity`.
    - Instantiate the handler function by calling `handleKeyboardInput` with the mock drone driver.
    - Create a `keyboard.KeyEvent` struct instance with the `Key` field set to `keyboard.A`.
    - (Optional) Redirect standard output to capture printed messages.
  Act:
    - Invoke the returned handler function, passing the created `keyboard.KeyEvent` instance as the `data` argument.
  Assert:
    - Verify that the `Left` method on the mock `tello.Driver` was called exactly once.
    - Verify that the argument passed to the `Left` method was equal to the predefined `intensity`.
    - Verify that no other movement methods (Right, Up, Down, etc.) on the mock driver were called.
    - (Optional) Verify that the string "Going left." was printed to standard output.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Asserting the `Left` method call with the correct `intensity` confirms the direct mapping between the 'A' key and the intended drone action. Checking that other methods weren't called ensures no unintended side effects.
  Discuss the importance of the test in relation to the application's behavior or business requirements: This test is crucial for ensuring basic directional control of the drone via the keyboard interface. Correct mapping is fundamental to user interaction.

```

```
Scenario 2: Test 'D' Key Press Triggers Right Movement

Details:
  Description: This test verifies that a 'KeyEvent' with 'Key' set to 'keyboard.D' results in a call to the 'Right' method on the 'tello.Driver' with the correct 'intensity'.
Execution:
  Arrange:
    - Create a mock `tello.Driver`.
    - Define `intensity`.
    - Get the handler function via `handleKeyboardInput(mockDriver)`.
    - Create a `keyboard.KeyEvent{Key: keyboard.D}`.
    - (Optional) Redirect stdout.
  Act:
    - Call the handler function with the 'D' key event.
  Assert:
    - Verify `mockDriver.Right` was called once with `intensity`.
    - Verify other movement/action methods were not called.
    - (Optional) Verify "Going right." was printed.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Similar to Scenario 1, this confirms the 'D' key correctly maps to the `Right` drone command.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures rightward keyboard control functions as expected.

```

```
Scenario 3: Test 'W' Key Press Triggers Up Movement

Details:
  Description: This test ensures that a 'KeyEvent' with 'Key' set to 'keyboard.W' correctly invokes the 'Up' method on the 'tello.Driver'.
Execution:
  Arrange:
    - Mock `tello.Driver`.
    - Define `intensity`.
    - Get handler: `handleKeyboardInput(mockDriver)`.
    - Create `keyboard.KeyEvent{Key: keyboard.W}`.
    - (Optional) Redirect stdout.
  Act:
    - Call handler with 'W' key event.
  Assert:
    - Verify `mockDriver.Up` was called once with `intensity`.
    - Verify other movement/action methods were not called.
    - (Optional) Verify "Going up." was printed.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Confirms the 'W' key maps to the `Up` drone command.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures upward keyboard control functions as expected.

```

```
Scenario 4: Test 'S' Key Press Triggers Down Movement

Details:
  Description: This test ensures that a 'KeyEvent' with 'Key' set to 'keyboard.S' correctly invokes the 'Down' method on the 'tello.Driver'.
Execution:
  Arrange:
    - Mock `tello.Driver`.
    - Define `intensity`.
    - Get handler: `handleKeyboardInput(mockDriver)`.
    - Create `keyboard.KeyEvent{Key: keyboard.S}`.
    - (Optional) Redirect stdout.
  Act:
    - Call handler with 'S' key event.
  Assert:
    - Verify `mockDriver.Down` was called once with `intensity`.
    - Verify other movement/action methods were not called.
    - (Optional) Verify "Going down." was printed.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Confirms the 'S' key maps to the `Down` drone command.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures downward keyboard control functions as expected.

```

```
Scenario 5: Test 'U' Key Press Triggers Forward Movement

Details:
  Description: This test verifies that a 'KeyEvent' with 'Key' set to 'keyboard.U' results in a call to the 'Forward' method on the 'tello.Driver'.
Execution:
  Arrange:
    - Mock `tello.Driver`.
    - Define `intensity`.
    - Get handler: `handleKeyboardInput(mockDriver)`.
    - Create `keyboard.KeyEvent{Key: keyboard.U}`.
    - (Optional) Redirect stdout.
  Act:
    - Call handler with 'U' key event.
  Assert:
    - Verify `mockDriver.Forward` was called once with `intensity`.
    - Verify other movement/action methods were not called.
    - (Optional) Verify "Going forward." was printed.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Confirms the 'U' key maps to the `Forward` drone command.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures forward keyboard control functions as expected.

```

```
Scenario 6: Test 'J' Key Press Triggers Backward Movement

Details:
  Description: This test verifies that a 'KeyEvent' with 'Key' set to 'keyboard.J' results in a call to the 'Backward' method on the 'tello.Driver'.
Execution:
  Arrange:
    - Mock `tello.Driver`.
    - Define `intensity`.
    - Get handler: `handleKeyboardInput(mockDriver)`.
    - Create `keyboard.KeyEvent{Key: keyboard.J}`.
    - (Optional) Redirect stdout.
  Act:
    - Call handler with 'J' key event.
  Assert:
    - Verify `mockDriver.Backward` was called once with `intensity`.
    - Verify other movement/action methods were not called.
    - (Optional) Verify "Going backward." was printed.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Confirms the 'J' key maps to the `Backward` drone command.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures backward keyboard control functions as expected.

```

```
Scenario 7: Test 'K' Key Press Triggers Counter-Clockwise Rotation

Details:
  Description: This test verifies that a 'KeyEvent' with 'Key' set to 'keyboard.K' results in a call to the 'CounterClockwise' method on the 'tello.Driver'.
Execution:
  Arrange:
    - Mock `tello.Driver`.
    - Define `intensity`.
    - Get handler: `handleKeyboardInput(mockDriver)`.
    - Create `keyboard.KeyEvent{Key: keyboard.K}`.
    - (Optional) Redirect stdout.
  Act:
    - Call handler with 'K' key event.
  Assert:
    - Verify `mockDriver.CounterClockwise` was called once with `intensity`.
    - Verify other movement/action methods were not called.
    - (Optional) Verify "Rotating counter-clockwise." was printed.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Confirms the 'K' key maps to the `CounterClockwise` drone command.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures counter-clockwise rotation control functions as expected.

```

```
Scenario 8: Test 'H' Key Press Triggers Clockwise Rotation

Details:
  Description: This test verifies that a 'KeyEvent' with 'Key' set to 'keyboard.H' results in a call to the 'Clockwise' method on the 'tello.Driver'.
Execution:
  Arrange:
    - Mock `tello.Driver`.
    - Define `intensity`.
    - Get handler: `handleKeyboardInput(mockDriver)`.
    - Create `keyboard.KeyEvent{Key: keyboard.H}`.
    - (Optional) Redirect stdout.
  Act:
    - Call handler with 'H' key event.
  Assert:
    - Verify `mockDriver.Clockwise` was called once with `intensity`.
    - Verify other movement/action methods were not called.
    - (Optional) Verify "Rotating clockwise." was printed.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Confirms the 'H' key maps to the `Clockwise` drone command.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures clockwise rotation control functions as expected.

```

```
Scenario 9: Test 'L' Key Press Triggers Landing

Details:
  Description: This test verifies that a 'KeyEvent' with 'Key' set to 'keyboard.L' results in a call to the 'Land' method on the 'tello.Driver'.
Execution:
  Arrange:
    - Mock `tello.Driver`.
    - Get handler: `handleKeyboardInput(mockDriver)`.
    - Create `keyboard.KeyEvent{Key: keyboard.L}`.
    - (Optional) Redirect stdout.
  Act:
    - Call handler with 'L' key event.
  Assert:
    - Verify `mockDriver.Land` was called exactly once.
    - Verify no movement methods or `TakeOff` were called.
    - (Optional) Verify "Landing drone" was printed.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Confirms the 'L' key maps to the `Land` drone command, which takes no intensity argument.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures the critical landing function can be triggered via the keyboard.

```

```
Scenario 10: Test 'T' Key Press Triggers Take Off

Details:
  Description: This test verifies that a 'KeyEvent' with 'Key' set to 'keyboard.T' results in a call to the 'TakeOff' method on the 'tello.Driver'.
Execution:
  Arrange:
    - Mock `tello.Driver`.
    - Get handler: `handleKeyboardInput(mockDriver)`.
    - Create `keyboard.KeyEvent{Key: keyboard.T}`.
    - (Optional) Redirect stdout.
  Act:
    - Call handler with 'T' key event.
  Assert:
    - Verify `mockDriver.TakeOff` was called exactly once.
    - Verify no movement methods or `Land` were called.
    - (Optional) Verify "Take off drone" was printed.
Validation:
  Explain the choice of assertion and the logic behind the expected result: Confirms the 'T' key maps to the `TakeOff` drone command.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures the critical take-off function can be triggered via the keyboard.

```

```
Scenario 11: Test Unrecognized Key Press Triggers Default Action (resetDronePosition)

Details:
  Description: This test verifies that when a 'KeyEvent' with a key not explicitly handled by the switch statement (e.g., 'X') is received, the default case is executed, which should call the `resetDronePosition` function.
Execution:
  Arrange:
    - Mock `tello.Driver`.
    - Create a mock or spy for the `resetDronePosition` function to track if it was called and with which arguments.
    - Get handler: `handleKeyboardInput(mockDriver)`.
    - Create a `keyboard.KeyEvent` with an unmapped key (e.g., `keyboard.X` or any other key not in {A,D,W,S,U,J,K,H,L,T}).
  Act:
    - Call the handler function with the unrecognized key event.
  Assert:
    - Verify that the mock `resetDronePosition` function was called exactly once.
    - Verify that the argument passed to `resetDronePosition` was the mock `tello.Driver` instance.
    - Verify that none of the specific drone action methods (Left, Right, Up, Down, Forward, Backward, Clockwise, CounterClockwise, Land, TakeOff) were called on the mock driver.
Validation:
  Explain the choice of assertion and the logic behind the expected result: This assertion confirms that the default case of the switch statement correctly delegates to the intended fallback function (`resetDronePosition`) when an unknown key is pressed.
  Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures that pressing unassigned keys results in a defined, safe behavior (presumably stopping or hovering via `resetDronePosition`) rather than causing errors or unexpected drone movements.

```

```
Scenario 12: Test Handler with Incorrect Data Type (Non-KeyEvent)

Details:
  Description: This test verifies the behavior of the handler function when the input `data` interface{} cannot be type-asserted to `keyboard.KeyEvent`. The expected behavior is a panic due to the direct type assertion `data.(keyboard.KeyEvent)`.
Execution:
  Arrange:
    - Mock `tello.Driver`.
    - Get handler: `handleKeyboardInput(mockDriver)`.
    - Create data of an incorrect type (e.g., `data := "not a key event"` or `data := 123`).
  Act:
    - Call the handler function with the incorrect data type. Use a `defer` and `recover()` mechanism within the test to catch the expected panic.
  Assert:
    - Assert that a panic occurred during the execution of the handler function.
    - Verify that no methods were called on the mock `tello.Driver`.
    - Verify that the mock `resetDronePosition` function was not called.
Validation:
  Explain the choice of assertion and the logic behind the expected result: The function uses a direct type assertion without checking its success. Go's behavior is to panic if the assertion fails. This test confirms that this potentially unsafe code path behaves as expected (panics).
  Discuss the importance of the test in relation to the application's behavior or business requirements: This highlights a potential fragility in the handler. While the `gobot` framework likely ensures correct types, testing this edge case confirms the consequence of unexpected input, which might inform decisions about adding type checks and error handling for robustness.

```

---
**Note:** These scenarios assume:
1.  The existence and accessibility of a package-level variable named `intensity`.
2.  The existence and accessibility of a function named `resetDronePosition(drone *tello.Driver)`.
3.  The ability to create mock implementations for `tello.Driver` and potentially `resetDronePosition` to verify interactions.
4.  The `keyboard.Key` constants (like `keyboard.A`, `keyboard.D`, etc.) are defined within the `gobot.io/x/gobot/platforms/keyboard` package.
*/

// ********RoostGPT********

package TelloDrone

import (
	"bytes"
	"io"
	"os"
	"runtime/debug"
	"strings"
	"testing"

	"gobot.io/x/gobot/platforms/dji/tello"
	"gobot.io/x/gobot/platforms/keyboard"
)

var intensity int
var mockResetDronePosition func(*tello.Driver)
var originalResetDronePosition func(*tello.Driver)

func TestHandleKeyboardInput(t *testing.T) {

	const testIntensity = 50

	var mockResetCalled bool
	var mockResetArg *tello.Driver
	originalResetDronePosition = resetDronePostion
	mockResetDronePosition = func(drone *tello.Driver) {
		mockResetCalled = true
		mockResetArg = drone

	}
	resetDronePostion = mockResetDronePosition

	defer func() {
		resetDronePostion = originalResetDronePosition
	}()

	testCases := []struct {
		name              string
		keyEvent          interface{}
		expectedMethod    string
		expectedIntensity int
		expectedOutput    string
		expectPanic       bool
	}{
		{
			name:              "Scenario 1: 'A' Key Press Triggers Left Movement",
			keyEvent:          keyboard.KeyEvent{Key: keyboard.A},
			expectedMethod:    "Left",
			expectedIntensity: testIntensity,
			expectedOutput:    "Going left.",
			expectPanic:       false,
		},
		{
			name:              "Scenario 2: 'D' Key Press Triggers Right Movement",
			keyEvent:          keyboard.KeyEvent{Key: keyboard.D},
			expectedMethod:    "Right",
			expectedIntensity: testIntensity,
			expectedOutput:    "Going right.",
			expectPanic:       false,
		},
		{
			name:              "Scenario 3: 'W' Key Press Triggers Up Movement",
			keyEvent:          keyboard.KeyEvent{Key: keyboard.W},
			expectedMethod:    "Up",
			expectedIntensity: testIntensity,
			expectedOutput:    "Going up.",
			expectPanic:       false,
		},
		{
			name:              "Scenario 4: 'S' Key Press Triggers Down Movement",
			keyEvent:          keyboard.KeyEvent{Key: keyboard.S},
			expectedMethod:    "Down",
			expectedIntensity: testIntensity,
			expectedOutput:    "Going down.",
			expectPanic:       false,
		},
		{
			name:              "Scenario 5: 'U' Key Press Triggers Forward Movement",
			keyEvent:          keyboard.KeyEvent{Key: keyboard.U},
			expectedMethod:    "Forward",
			expectedIntensity: testIntensity,
			expectedOutput:    "Going forward.",
			expectPanic:       false,
		},
		{
			name:              "Scenario 6: 'J' Key Press Triggers Backward Movement",
			keyEvent:          keyboard.KeyEvent{Key: keyboard.J},
			expectedMethod:    "Backward",
			expectedIntensity: testIntensity,
			expectedOutput:    "Going backward.",
			expectPanic:       false,
		},
		{
			name:              "Scenario 7: 'K' Key Press Triggers Counter-Clockwise Rotation",
			keyEvent:          keyboard.KeyEvent{Key: keyboard.K},
			expectedMethod:    "CounterClockwise",
			expectedIntensity: testIntensity,
			expectedOutput:    "Rotating counter-clockwise.",
			expectPanic:       false,
		},
		{
			name:              "Scenario 8: 'H' Key Press Triggers Clockwise Rotation",
			keyEvent:          keyboard.KeyEvent{Key: keyboard.H},
			expectedMethod:    "Clockwise",
			expectedIntensity: testIntensity,
			expectedOutput:    "Rotating clockwise.",
			expectPanic:       false,
		},
		{
			name:           "Scenario 9: 'L' Key Press Triggers Landing",
			keyEvent:       keyboard.KeyEvent{Key: keyboard.L},
			expectedMethod: "Land",
			expectedOutput: "Landing drone",
			expectPanic:    false,
		},
		{
			name:           "Scenario 10: 'T' Key Press Triggers Take Off",
			keyEvent:       keyboard.KeyEvent{Key: keyboard.T},
			expectedMethod: "TakeOff",
			expectedOutput: "Take off drone",
			expectPanic:    false,
		},
		{
			name:           "Scenario 11: Unrecognized Key Press Triggers Default Action (resetDronePosition)",
			keyEvent:       keyboard.KeyEvent{Key: keyboard.X},
			expectedMethod: "Reset",
			expectedOutput: "",
			expectPanic:    false,
		},
		{
			name:           "Scenario 12: Handler with Incorrect Data Type (Non-KeyEvent)",
			keyEvent:       "not a key event",
			expectedMethod: "Panic",
			expectedOutput: "",
			expectPanic:    true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {

			mockDriver := &mockTelloDriver{}

			var driverInstance *tello.Driver

			dummyDriver := &tello.Driver{}
			handler := handleKeyboardInput(dummyDriver)

			*mockDriver = mockTelloDriver{}
			mockResetCalled = false
			mockResetArg = nil

			originalIntensity := intensity
			intensity = testIntensity
			defer func() { intensity = originalIntensity }()

			var panicked bool
			defer func() {
				r := recover()
				if r != nil {
					panicked = true
					t.Logf("Recovered from panic: %v\n%s", r, string(debug.Stack()))
					if !tc.expectPanic {
						t.Errorf("Test case %q panicked unexpectedly.", tc.name)
					} else {
						t.Logf("Test case %q correctly panicked.", tc.name)
					}
				} else if tc.expectPanic {
					t.Errorf("Test case %q did not panic as expected.", tc.name)
				}
			}()

			output := captureOutput(func() {
				handler(tc.keyEvent)
			})

			if panicked {

				if mockDriver.leftCalled || mockDriver.rightCalled || mockDriver.upCalled || mockDriver.downCalled ||
					mockDriver.forwardCalled || mockDriver.backwardCalled || mockDriver.counterClockwiseCalled ||
					mockDriver.clockwiseCalled || mockDriver.landCalled || mockDriver.takeOffCalled {
					t.Errorf("Expected no driver methods to be called before panic, but some were.")
				}
				if mockResetCalled {
					t.Errorf("Expected resetDronePosition not to be called before panic, but it was.")
				}
				return
			}

			if output != tc.expectedOutput {
				t.Errorf("Expected output %q, but got %q", tc.expectedOutput, output)
			} else {
				t.Logf("Output matched expected: %q", output)
			}

			switch tc.expectedMethod {
			case "Left":
				if !mockDriver.leftCalled {
					t.Errorf("Expected Left() to be called, but it wasn't.")
				} else if mockDriver.leftIntensity != tc.expectedIntensity {
					t.Errorf("Expected Left() intensity %d, but got %d", tc.expectedIntensity, mockDriver.leftIntensity)
				} else {
					t.Logf("Left(%d) called correctly.", mockDriver.leftIntensity)
				}

				if mockDriver.rightCalled || mockDriver.upCalled || mockDriver.downCalled || mockDriver.forwardCalled || mockDriver.backwardCalled || mockDriver.counterClockwiseCalled || mockDriver.clockwiseCalled || mockDriver.landCalled || mockDriver.takeOffCalled || mockResetCalled {
					t.Errorf("Expected only Left() to be called, but other methods were called.")
				}
			case "Right":
				if !mockDriver.rightCalled {
					t.Errorf("Expected Right() to be called, but it wasn't.")
				} else if mockDriver.rightIntensity != tc.expectedIntensity {
					t.Errorf("Expected Right() intensity %d, but got %d", tc.expectedIntensity, mockDriver.rightIntensity)
				} else {
					t.Logf("Right(%d) called correctly.", mockDriver.rightIntensity)
				}
				if mockDriver.leftCalled || mockDriver.upCalled || mockDriver.downCalled || mockDriver.forwardCalled || mockDriver.backwardCalled || mockDriver.counterClockwiseCalled || mockDriver.clockwiseCalled || mockDriver.landCalled || mockDriver.takeOffCalled || mockResetCalled {
					t.Errorf("Expected only Right() to be called, but other methods were called.")
				}
			case "Up":
				if !mockDriver.upCalled {
					t.Errorf("Expected Up() to be called, but it wasn't.")
				} else if mockDriver.upIntensity != tc.expectedIntensity {
					t.Errorf("Expected Up() intensity %d, but got %d", tc.expectedIntensity, mockDriver.upIntensity)
				} else {
					t.Logf("Up(%d) called correctly.", mockDriver.upIntensity)
				}
				if mockDriver.leftCalled || mockDriver.rightCalled || mockDriver.downCalled || mockDriver.forwardCalled || mockDriver.backwardCalled || mockDriver.counterClockwiseCalled || mockDriver.clockwiseCalled || mockDriver.landCalled || mockDriver.takeOffCalled || mockResetCalled {
					t.Errorf("Expected only Up() to be called, but other methods were called.")
				}
			case "Down":
				if !mockDriver.downCalled {
					t.Errorf("Expected Down() to be called, but it wasn't.")
				} else if mockDriver.downIntensity != tc.expectedIntensity {
					t.Errorf("Expected Down() intensity %d, but got %d", tc.expectedIntensity, mockDriver.downIntensity)
				} else {
					t.Logf("Down(%d) called correctly.", mockDriver.downIntensity)
				}
				if mockDriver.leftCalled || mockDriver.rightCalled || mockDriver.upCalled || mockDriver.forwardCalled || mockDriver.backwardCalled || mockDriver.counterClockwiseCalled || mockDriver.clockwiseCalled || mockDriver.landCalled || mockDriver.takeOffCalled || mockResetCalled {
					t.Errorf("Expected only Down() to be called, but other methods were called.")
				}
			case "Forward":
				if !mockDriver.forwardCalled {
					t.Errorf("Expected Forward() to be called, but it wasn't.")
				} else if mockDriver.forwardIntensity != tc.expectedIntensity {
					t.Errorf("Expected Forward() intensity %d, but got %d", tc.expectedIntensity, mockDriver.forwardIntensity)
				} else {
					t.Logf("Forward(%d) called correctly.", mockDriver.forwardIntensity)
				}
				if mockDriver.leftCalled || mockDriver.rightCalled || mockDriver.upCalled || mockDriver.downCalled || mockDriver.backwardCalled || mockDriver.counterClockwiseCalled || mockDriver.clockwiseCalled || mockDriver.landCalled || mockDriver.takeOffCalled || mockResetCalled {
					t.Errorf("Expected only Forward() to be called, but other methods were called.")
				}
			case "Backward":
				if !mockDriver.backwardCalled {
					t.Errorf("Expected Backward() to be called, but it wasn't.")
				} else if mockDriver.backwardIntensity != tc.expectedIntensity {
					t.Errorf("Expected Backward() intensity %d, but got %d", tc.expectedIntensity, mockDriver.backwardIntensity)
				} else {
					t.Logf("Backward(%d) called correctly.", mockDriver.backwardIntensity)
				}
				if mockDriver.leftCalled || mockDriver.rightCalled || mockDriver.upCalled || mockDriver.downCalled || mockDriver.forwardCalled || mockDriver.counterClockwiseCalled || mockDriver.clockwiseCalled || mockDriver.landCalled || mockDriver.takeOffCalled || mockResetCalled {
					t.Errorf("Expected only Backward() to be called, but other methods were called.")
				}
			case "CounterClockwise":
				if !mockDriver.counterClockwiseCalled {
					t.Errorf("Expected CounterClockwise() to be called, but it wasn't.")
				} else if mockDriver.counterClockwiseIntensity != tc.expectedIntensity {
					t.Errorf("Expected CounterClockwise() intensity %d, but got %d", tc.expectedIntensity, mockDriver.counterClockwiseIntensity)
				} else {
					t.Logf("CounterClockwise(%d) called correctly.", mockDriver.counterClockwiseIntensity)
				}
				if mockDriver.leftCalled || mockDriver.rightCalled || mockDriver.upCalled || mockDriver.downCalled || mockDriver.forwardCalled || mockDriver.backwardCalled || mockDriver.clockwiseCalled || mockDriver.landCalled || mockDriver.takeOffCalled || mockResetCalled {
					t.Errorf("Expected only CounterClockwise() to be called, but other methods were called.")
				}
			case "Clockwise":
				if !mockDriver.clockwiseCalled {
					t.Errorf("Expected Clockwise() to be called, but it wasn't.")
				} else if mockDriver.clockwiseIntensity != tc.expectedIntensity {
					t.Errorf("Expected Clockwise() intensity %d, but got %d", tc.expectedIntensity, mockDriver.clockwiseIntensity)
				} else {
					t.Logf("Clockwise(%d) called correctly.", mockDriver.clockwiseIntensity)
				}
				if mockDriver.leftCalled || mockDriver.rightCalled || mockDriver.upCalled || mockDriver.downCalled || mockDriver.forwardCalled || mockDriver.backwardCalled || mockDriver.counterClockwiseCalled || mockDriver.landCalled || mockDriver.takeOffCalled || mockResetCalled {
					t.Errorf("Expected only Clockwise() to be called, but other methods were called.")
				}
			case "Land":
				if !mockDriver.landCalled {
					t.Errorf("Expected Land() to be called, but it wasn't.")
				} else {
					t.Logf("Land() called correctly.")
				}
				if mockDriver.leftCalled || mockDriver.rightCalled || mockDriver.upCalled || mockDriver.downCalled || mockDriver.forwardCalled || mockDriver.backwardCalled || mockDriver.counterClockwiseCalled || mockDriver.clockwiseCalled || mockDriver.takeOffCalled || mockResetCalled {
					t.Errorf("Expected only Land() to be called, but other methods were called.")
				}
			case "TakeOff":
				if !mockDriver.takeOffCalled {
					t.Errorf("Expected TakeOff() to be called, but it wasn't.")
				} else {
					t.Logf("TakeOff() called correctly.")
				}
				if mockDriver.leftCalled || mockDriver.rightCalled || mockDriver.upCalled || mockDriver.downCalled || mockDriver.forwardCalled || mockDriver.backwardCalled || mockDriver.counterClockwiseCalled || mockDriver.clockwiseCalled || mockDriver.landCalled || mockResetCalled {
					t.Errorf("Expected only TakeOff() to be called, but other methods were called.")
				}
			case "Reset":
				if !mockResetCalled {
					t.Errorf("Expected resetDronePosition() to be called, but it wasn't.")
				} else if mockResetArg != dummyDriver {
					t.Errorf("Expected resetDronePosition() to be called with the driver instance, but got %v", mockResetArg)
				} else {
					t.Logf("resetDronePosition() called correctly.")
				}

				if mockDriver.leftCalled || mockDriver.rightCalled || mockDriver.upCalled || mockDriver.downCalled || mockDriver.forwardCalled || mockDriver.backwardCalled || mockDriver.counterClockwiseCalled || mockDriver.clockwiseCalled || mockDriver.landCalled || mockDriver.takeOffCalled {
					t.Errorf("Expected no specific drone actions when resetDronePosition is called, but some were.")
				}
			case "Panic":

				t.Logf("Panic test scenario passed.")
			default:
				t.Fatalf("Unhandled expectedMethod type in test setup: %s", tc.expectedMethod)
			}
		})
	}
}
func captureOutput(f func()) string {
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	f()

	w.Close()
	os.Stdout = oldStdout
	var buf bytes.Buffer
	io.Copy(&buf, r)
	return strings.TrimSpace(buf.String())
}
func (m *mockTelloDriver) CounterClockwise(val int) error {

	m.counterClockwiseCalled = true
	m.counterClockwiseIntensity = val
	return nil
}
func (m *mockTelloDriver) Land() error {
	m.landCalled = true
	return nil
}
func (m *mockTelloDriver) TakeOff() error {
	m.takeOffCalled = true
	return nil
}
