// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-1 using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=fibonacci_5d6017f964
ROOST_METHOD_SIG_HASH=fibonacci_3c2494e9fa

Based on the provided Go function for calculating Fibonacci numbers, here are several test scenarios:

```
Scenario 1: Test Fibonacci of 0

Details:
  Description: Verify that the function correctly returns 0 for the 0th Fibonacci number.
Execution:
  Arrange: No special arrangement needed.
  Act: Call fibonacci(0)
  Assert: Check if the returned value is 0.
Validation:
  The 0th Fibonacci number is defined as 0. This test ensures the function handles the base case correctly.
  It's crucial to verify edge cases like this to ensure the function behaves correctly for all inputs.

Scenario 2: Test Fibonacci of 1

Details:
  Description: Verify that the function correctly returns 1 for the 1st Fibonacci number.
Execution:
  Arrange: No special arrangement needed.
  Act: Call fibonacci(1)
  Assert: Check if the returned value is 1.
Validation:
  The 1st Fibonacci number is defined as 1. This test verifies another base case of the sequence.
  Ensuring correct behavior for small inputs is essential for the overall accuracy of the function.

Scenario 3: Test Fibonacci of 10

Details:
  Description: Check if the function calculates the 10th Fibonacci number correctly.
Execution:
  Arrange: No special arrangement needed.
  Act: Call fibonacci(10)
  Assert: Verify that the returned value is 55.
Validation:
  The 10th Fibonacci number is 55. This test checks a typical use case of the function.
  It's important to test a "middle" value to ensure the function's loop is working correctly for multiple iterations.

Scenario 4: Test Fibonacci of a large number

Details:
  Description: Verify the function's behavior for a large input, testing its performance and accuracy.
Execution:
  Arrange: Choose a large number, e.g., 50.
  Act: Call fibonacci(50)
  Assert: Check if the returned value matches the known 50th Fibonacci number.
Validation:
  This test ensures the function can handle larger inputs without overflow or performance issues.
  It's crucial to test the limits of the function to understand its practical usability.

Scenario 5: Test Fibonacci of a negative number

Details:
  Description: Check how the function handles an invalid negative input.
Execution:
  Arrange: No special arrangement needed.
  Act: Call fibonacci(-1)
  Assert: Verify that the function returns 0 or handles the error appropriately.
Validation:
  While the function doesn't explicitly handle negative inputs, it's important to test how it behaves in such cases.
  This test helps identify if additional error handling is needed for invalid inputs.

Scenario 6: Test consecutive Fibonacci numbers

Details:
  Description: Verify that consecutive calls to the function produce correct Fibonacci sequence.
Execution:
  Arrange: No special arrangement needed.
  Act: Call fibonacci(n) and fibonacci(n+1) for several values of n.
  Assert: Check if each pair of consecutive calls produces numbers that adhere to the Fibonacci sequence rule (F(n+1) = F(n) + F(n-1)).
Validation:
  This test ensures that the function consistently produces correct Fibonacci numbers across multiple calls.
  It's important to verify the function's consistency and adherence to the Fibonacci sequence definition.

Scenario 7: Test Fibonacci of 2

Details:
  Description: Verify that the function correctly calculates the 2nd Fibonacci number.
Execution:
  Arrange: No special arrangement needed.
  Act: Call fibonacci(2)
  Assert: Check if the returned value is 1.
Validation:
  The 2nd Fibonacci number is 1. This test checks the transition from base cases to the general case.
  It's crucial to verify this case as it's the first number calculated using the function's main logic.
```

These scenarios cover various aspects of the fibonacci function, including base cases, typical usage, edge cases, and potential error conditions. They aim to thoroughly test the function's correctness and robustness.
*/

// ********RoostGPT********
package Fibonacci

import (
	"testing"
)

func Testfibonacci(t *testing.T) {
	tests := []struct {
		name     string
		input    int
		expected int
	}{
		{"Fibonacci of 0", 0, 0},
		{"Fibonacci of 1", 1, 1},
		{"Fibonacci of 10", 10, 55},
		{"Fibonacci of 50", 50, 12586269025},
		{"Fibonacci of negative number", -1, 0},
		{"Fibonacci of 2", 2, 1},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := fibonacci(tt.input)
			if result != tt.expected {
				t.Errorf("fibonacci(%d) = %d; want %d", tt.input, result, tt.expected)
			}
		})
	}

	// Test consecutive Fibonacci numbers
	t.Run("Consecutive Fibonacci numbers", func(t *testing.T) {
		for n := 0; n < 10; n++ {
			fib_n := fibonacci(n)
			fib_n_plus_1 := fibonacci(n + 1)
			fib_n_plus_2 := fibonacci(n + 2)
			if fib_n_plus_2 != fib_n+fib_n_plus_1 {
				t.Errorf("fibonacci(%d) + fibonacci(%d) != fibonacci(%d)", n, n+1, n+2)
			}
		}
	})
}
