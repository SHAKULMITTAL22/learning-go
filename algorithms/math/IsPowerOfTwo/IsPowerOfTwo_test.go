// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-dbrx using AI Type  and AI Model 

ROOST_METHOD_HASH=isPowerOfTwo_fe7a80abf8
ROOST_METHOD_SIG_HASH=isPowerOfTwo_a909b954a6

### Scenario 1: Test with a number that is a power of two

Details:
  Description: This test checks if the function correctly identifies numbers that are powers of two. A power of two means that it can be expressed as 2 raised to the power of some integer.
Execution:
  Arrange: Choose a number that is a known power of two, such as 8 (which is 2^3).
  Act: Call `isPowerOfTwo` with the number 8.
  Assert: The function should return `true`.
Validation:
  The assertion for this test is straightforward since 8 is 2^3 and should return `true` when checked with `isPowerOfTwo`. This test is crucial as it validates the function's ability to correctly identify valid powers of two, which is its primary purpose.

### Scenario 2: Test with a number that is not a power of two

Details:
  Description: This test verifies if the function can correctly identify numbers that are not powers of two.
Execution:
  Arrange: Choose a number that is not a power of two, such as 7.
  Act: Call `isPowerOfTwo` with the number 7.
  Assert: The function should return `false`.
Validation:
  Since 7 cannot be expressed as 2 raised to any integer, the function should return `false`. This test ensures that the function does not falsely identify non-powers as powers of two, maintaining integrity in its evaluation.

### Scenario 3: Test with the number one

Details:
  Description: This test checks the function's response when input is 1, which is technically 2^0 and should be considered a power of two.
Execution:
  Arrange: Use the number 1.
  Act: Call `isPowerOfTwo` with the number 1.
  Assert: The function should return `true`.
Validation:
  The number 1 is 2^0, and accordingly, it should return `true`. This test is important because it checks the function's handling of this edge case, which is the smallest power of two.

### Scenario 4: Test with zero

Details:
  Description: This test determines how the function handles zero, which is not a power of two.
Execution:
  Arrange: Use the number 0.
  Act: Call `isPowerOfTwo` with the number 0.
  Assert: The function should return `false`.
Validation:
  Zero is not a power of two as there is no exponent of two that results in zero. Ensuring the function returns `false` for this input verifies that it handles this special case correctly.

### Scenario 5: Test with a negative number

Details:
  Description: Tests the function's behavior with negative numbers, which are not powers of two.
Execution:
  Arrange: Use a negative number, such as -2.
  Act: Call `isPowerOfTwo` with the number -2.
  Assert: The function should return `false`.
Validation:
  Negative numbers cannot be powers of two, so the function should return `false`. This test confirms that the function properly handles negative inputs, which expands its robustness and error handling.

These scenarios collectively ensure that the function `isPowerOfTwo` is thoroughly tested against various typical and edge cases, verifying both its correctness and resilience.
*/

// ********RoostGPT********
package ispoweroftwo

import (
	"testing"
)

func TestIsPowerOfTwo(t *testing.T) {
	tests := []struct {
		name     string
		input    int
		expected bool
	}{
		{
			name:     "Power of Two - 8",
			input:    8,
			expected: true,
		},
		{
			name:     "Not a Power of Two - 7",
			input:    7,
			expected: false,
		},
		{
			name:     "Edge Case - 1 (2^0)",
			input:    1,
			expected: true,
		},
		{
			name:     "Zero Case",
			input:    0,
			expected: false,
		},
		{
			name:     "Negative Number",
			input:    -2,
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := isPowerOfTwo(tt.input)

			if result != tt.expected {
				t.Errorf("isPowerOfTwo(%d) = %t, expected %t", tt.input, result, tt.expected)
			} else {
				t.Logf("Success: %s", tt.name)
			}
		})
	}
}

// Suggestion in business logic:
// The function isPowerOfTwo should handle the case when num is 1 correctly.
// The current logic incorrectly returns false for isPowerOfTwo(1) due to the initial check `if num < 2`.
// The correct behavior should be to check `if num <= 0` to handle non-positive numbers properly.
