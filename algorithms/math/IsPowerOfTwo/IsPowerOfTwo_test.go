// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-dbrx using AI Type  and AI Model 

ROOST_METHOD_HASH=isPowerOfTwo_fe7a80abf8
ROOST_METHOD_SIG_HASH=isPowerOfTwo_a909b954a6

### Scenario 1: Test with a number that is a power of two

Details:
  Description: This test checks if the function correctly identifies a number that is a power of two (e.g., 8 which is 2^3).
Execution:
  Arrange: Prepare an input integer that is a known power of two, such as 8.
  Act: Call the `isPowerOfTwo` function with this integer.
  Assert: Verify that the function returns `true`.
Validation:
  The assertion checks if the function returns `true` for a valid power of two, which is crucial for validating the function's ability to correctly identify powers of two. This test ensures that the function behaves as expected for valid input conditions.

### Scenario 2: Test with a number that is not a power of two

Details:
  Description: This test checks if the function correctly identifies a number that is not a power of two (e.g., 7).
Execution:
  Arrange: Prepare an integer that is not a power of two, such as 7.
  Act: Call the `isPowerOfTwo` function with this integer.
  Assert: Verify that the function returns `false`.
Validation:
  The assertion checks if the function returns `false` for numbers that are not powers of two. This test is important to confirm that the function can accurately distinguish non-power of two numbers, ensuring reliability in diverse inputs.

### Scenario 3: Test with the smallest number not a power of two

Details:
  Description: This test checks if the function correctly identifies the smallest integer greater than 1 that is not a power of two, which is 3.
Execution:
  Arrange: Use the integer 3 as the test input.
  Act: Call the `isPowerOfTwo` function with this integer.
  Assert: Verify that the function returns `false`.
Validation:
  Testing with the smallest non-power of two integer greater than 1 ensures the function's accuracy at the boundary of the smallest values. It helps in catching off-by-one errors or incorrect loop conditions.

### Scenario 4: Test with zero

Details:
  Description: This test checks the function's response when provided with zero, which is not a power of two.
Execution:
  Arrange: Set up zero as the input.
  Act: Call the `isPowerOfTwo` function with zero.
  Assert: Verify that the function returns `false`.
Validation:
  Since zero is not a power of two, verifying that the function returns `false` confirms that the function handles this edge case correctly. This test is essential for ensuring robustness in handling non-positive numbers.

### Scenario 5: Test with negative numbers

Details:
  Description: This test verifies that any negative number returns `false`, as negative numbers cannot be powers of two.
Execution:
  Arrange: Use a negative number, such as -2, as the input.
  Act: Call the `isPowerOfTwo` function with this negative number.
  Assert: Verify that the function returns `false`.
Validation:
  Testing negative numbers ensures that the function correctly handles all non-valid inputs, maintaining the integrity of the function across all possible integer inputs.

### Scenario 6: Test with the number one

Details:
  Description: This test checks if the function treats the number one as not a power of two since it is technically 2^0.
Execution:
  Arrange: Use the integer 1 as the input.
  Act: Call the `isPowerOfTwo` function with this integer.
  Assert: Verify that the function returns `false`.
Validation:
  The assertion ensures the function adheres to the defined behavior in the function's initial check (`if num < 2`). Testing with 1 is crucial as it is a boundary condition and often a special case in power of two calculations.
*/

// ********RoostGPT********
package ispoweroftwo

import (
	"testing"
)

func TestIsPowerOfTwo(t *testing.T) {
	tests := []struct {
		description string
		input       int
		expected    bool
	}{
		{
			description: "Test with a number that is a power of two (e.g., 8 which is 2^3)",
			input:       8,
			expected:    true,
		},
		{
			description: "Test with a number that is not a power of two (e.g., 7)",
			input:       7,
			expected:    false,
		},
		{
			description: "Test with the smallest number not a power of two (3)",
			input:       3,
			expected:    false,
		},
		{
			description: "Test with zero",
			input:       0,
			expected:    false,
		},
		{
			description: "Test with negative numbers (-2)",
			input:       -2,
			expected:    false,
		},
		{
			description: "Test with the number one (1)",
			input:       1,
			expected:    true, // Updated expected result as 1 is a power of two (2^0)
		},
	}

	for _, tc := range tests {
		t.Run(tc.description, func(t *testing.T) {
			result := isPowerOfTwo(tc.input)
			if result != tc.expected {
				t.Errorf("Failed %s: expected %v, got %v", tc.description, tc.expected, result)
			}
		})
	}
}

// Note: Ensure the business logic in `isPowerOfTwo` function handles num == 1 correctly.
