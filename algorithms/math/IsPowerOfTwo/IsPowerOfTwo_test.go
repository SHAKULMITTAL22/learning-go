// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-dbrx using AI Type  and AI Model 

ROOST_METHOD_HASH=isPowerOfTwo_fe7a80abf8
ROOST_METHOD_SIG_HASH=isPowerOfTwo_a909b954a6

Here are several test scenarios for the `isPowerOfTwo` function, covering normal operations, edge cases, and potential pitfalls:

---

Scenario 1: Test with a Small Power of Two

Details:
  Description: Verify that the function correctly identifies a small positive integer that is a power of two.
  Execution:
    Arrange: Choose a small number like 8, which is a power of two.
    Act: Call `isPowerOfTwo(8)`.
    Assert: Check that the result is `true`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Since 8 is 2^3, it should return `true`.
    Discuss the importance of the test in relation to the application's behavior or business requirements: This test ensures that the function correctly identifies powers of two, a fundamental requirement of its purpose.

---

Scenario 2: Test with a Small Non-Power of Two

Details:
  Description: Verify that the function correctly identifies a small positive integer that is not a power of two.
  Execution:
    Arrange: Choose a small number like 3, which is not a power of two.
    Act: Call `isPowerOfTwo(3)`.
    Assert: Check that the result is `false`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Since 3 is not a power of two, it should return `false`.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures the function does not falsely identify non-powers of two as powers of two.

---

Scenario 3: Test with One

Details:
  Description: Verify the function's behavior with the number 1, which is a special case since it's 2^0.
  Execution:
    Arrange: Use the number 1.
    Act: Call `isPowerOfTwo(1)`.
    Assert: Check that the result is `false`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: The function is expected to return `false` for numbers less than 2 based on the implementation.
    Discuss the importance of the test in relation to the application's behavior or business requirements: This test verifies handling of edge cases, ensuring the function adheres to its defined behavior.

---

Scenario 4: Test with Zero

Details:
  Description: Check the function's behavior with zero, an edge case.
  Execution:
    Arrange: Use the number 0.
    Act: Call `isPowerOfTwo(0)`.
    Assert: Check that the result is `false`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Zero is not a power of two, and the function should return `false`.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Validates that the function handles edge cases correctly, preventing logical errors in applications using this function.

---

Scenario 5: Test with Negative Numbers

Details:
  Description: Ensure the function returns `false` for negative numbers.
  Execution:
    Arrange: Use a negative number, such as -16.
    Act: Call `isPowerOfTwo(-16)`.
    Assert: Check that the result is `false`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Negative numbers cannot be powers of two, so the function should return `false`.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures robustness by confirming that the function does not accept invalid input as a power of two.

---

Scenario 6: Test with Large Power of Two

Details:
  Description: Verify that the function handles large powers of two correctly.
  Execution:
    Arrange: Use a large number like 1024, which is a power of two.
    Act: Call `isPowerOfTwo(1024)`.
    Assert: Check that the result is `true`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: 1024 is 2^10, so it should return `true`.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Tests the function's capability to handle larger numbers accurately.

---

Scenario 7: Test with Large Non-Power of Two

Details:
  Description: Verify the function's behavior with a large number that is not a power of two.
  Execution:
    Arrange: Use a large number like 1000, which is not a power of two.
    Act: Call `isPowerOfTwo(1000)`.
    Assert: Check that the result is `false`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Since 1000 is not a power of two, it should return `false`.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures the function's accuracy with large non-power inputs, crucial for applications dealing with large data sets.

---

These scenarios are designed to ensure comprehensive coverage of the `isPowerOfTwo` function's expected behavior, handling both typical cases and edge conditions.
*/

// ********RoostGPT********
package ispoweroftwo

import (
	"bytes"
	"fmt"
	"os"
	"testing"
)

func TestIsPowerOfTwo(t *testing.T) {
	tests := []struct {
		name     string
		input    int
		expected bool
	}{
		{
			name:     "Small Power of Two",
			input:    8,
			expected: true,
		},
		{
			name:     "Small Non-Power of Two",
			input:    3,
			expected: false,
		},
		{
			name:     "Special Case One",
			input:    1,
			expected: true, // This should be true, as 1 is 2^0
		},
		{
			name:     "Edge Case Zero",
			input:    0,
			expected: false,
		},
		{
			name:     "Negative Number",
			input:    -16,
			expected: false,
		},
		{
			name:     "Large Power of Two",
			input:    1024,
			expected: true,
		},
		{
			name:     "Large Non-Power of Two",
			input:    1000,
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Logf("Running test: %s", tt.name)
			result := isPowerOfTwo(tt.input)
			if result != tt.expected {
				t.Errorf("Expected %v for input %d, but got %v", tt.expected, tt.input, result)
			} else {
				t.Logf("Success: Expected %v and got %v for input %d", tt.expected, result, tt.input)
			}
		})
	}
}

// Example function to demonstrate non-returning function test using os.Stdout
func printPowerOfTwo(num int) {
	if isPowerOfTwo(num) {
		fmt.Fprintf(os.Stdout, "%d is a power of two\n", num)
	} else {
		fmt.Fprintf(os.Stdout, "%d is not a power of two\n", num)
	}
}

func TestPrintPowerOfTwo(t *testing.T) {
	tests := []struct {
		name     string
		input    int
		expected string
	}{
		{
			name:     "Print Power of Two",
			input:    8,
			expected: "8 is a power of two\n",
		},
		{
			name:     "Print Non-Power of Two",
			input:    3,
			expected: "3 is not a power of two\n",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var buf bytes.Buffer
			os.Stdout = &buf
			printPowerOfTwo(tt.input)
			os.Stdout = os.Stdout // Resetting to default stdout

			if buf.String() != tt.expected {
				t.Errorf("Expected output %q, but got %q", tt.expected, buf.String())
			} else {
				t.Logf("Success: Expected output %q and got %q", tt.expected, buf.String())
			}
		})
	}
}

// Note: Ensure that the file names are consistent and not case-sensitive to avoid collisions.
