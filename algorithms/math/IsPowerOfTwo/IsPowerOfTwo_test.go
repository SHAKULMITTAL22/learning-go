// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-dbrx using AI Type  and AI Model 

ROOST_METHOD_HASH=isPowerOfTwo_fe7a80abf8
ROOST_METHOD_SIG_HASH=isPowerOfTwo_a909b954a6

### Scenario 1: Test with a number that is a power of two

Details:
  Description: This test checks if the function correctly identifies numbers that are powers of two. A power of two means that it can be expressed as 2 raised to the power of some integer.
Execution:
  Arrange: Choose a number that is a known power of two, such as 8 (which is 2^3).
  Act: Call `isPowerOfTwo` with the number 8.
  Assert: The function should return `true` indicating that 8 is a power of two.
Validation:
  The assertion checks for a `true` return value when passed a power of two. This test is important to validate that the function fulfills its primary purpose of identifying powers of two, which might be critical for optimizations or specific business rules in the application.

### Scenario 2: Test with a number that is not a power of two

Details:
  Description: This test verifies if the function can correctly identify numbers that are not powers of two.
Execution:
  Arrange: Choose a non-power of two number, such as 7.
  Act: Call `isPowerOfTwo` with the number 7.
  Assert: The function should return `false` indicating that 7 is not a power of two.
Validation:
  The assertion checks for a `false` return value for non-powers of two. This confirms the function's ability to correctly filter out numbers that do not meet the criteria, which is as important as identifying valid cases.

### Scenario 3: Test with the smallest non-power of two integer (1)

Details:
  Description: Tests the edge case where the number is 1, which is technically 2^0 and should be considered a power of two.
Execution:
  Arrange: Use the number 1.
  Act: Call `isPowerOfTwo` with the number 1.
  Assert: The function should return `true` because 1 is 2^0.
Validation:
  Although the function's initial check (`if num < 2`) might suggest numbers less than 2 are not considered, 1 is a special case as 2^0. This test ensures that this edge case is handled correctly, reflecting an accurate implementation of the mathematical definition of powers of two.

### Scenario 4: Test with zero

Details:
  Description: Checks how the function handles the value 0, which is not a power of two.
Execution:
  Arrange: Use the number 0.
  Act: Call `isPowerOfTwo` with the number 0.
  Assert: The function should return `false` as 0 is not a power of two.
Validation:
  Testing with 0 checks the function's robustness in handling edge cases around the lower boundary condition. This is crucial for ensuring that the function behaves predictably with input at the boundary of its operational domain.

### Scenario 5: Test with a negative number

Details:
  Description: Tests how the function behaves when given a negative number, which should not be considered a power of two.
Execution:
  Arrange: Use a negative number, such as -8.
  Act: Call `isPowerOfTwo` with the number -8.
  Assert: The function should return `false` as negative numbers cannot be powers of two.
Validation:
  This test is important for ensuring that the function can handle unexpected input types gracefully and still produce a logically correct output, maintaining the integrity of the application's data processing logic. Negative numbers represent invalid input for this function, and ensuring they are handled correctly is crucial for overall application stability.
*/

// ********RoostGPT********
package IsPowerOfTwo

import (
	"testing"
)

// Comment: The function isPowerOfTwo needs to handle the case where num is exactly 1, as 1 is a power of two (2^0).
// Additionally, the function should return true for any case where num is a power of two, including num = 1.
// The function currently incorrectly returns false for num = 1.

func TestIsPowerOfTwo(t *testing.T) {
	tests := []struct {
		name     string
		input    int
		expected bool
	}{
		{
			name:     "Power of two (8)",
			input:    8,
			expected: true,
		},
		{
			name:     "Not a power of two (7)",
			input:    7,
			expected: false,
		},
		{
			name:     "Edge case power of two (1)",
			input:    1,
			expected: true,
		},
		{
			name:     "Zero case",
			input:    0,
			expected: false,
		},
		{
			name:     "Negative number (-8)",
			input:    -8,
			expected: false,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			result := isPowerOfTwo(tc.input)
			if result != tc.expected {
				t.Errorf("Failed %s: expected %v, got %v", tc.name, tc.expected, result)
			} else {
				t.Logf("Success %s: expected %v, got %v", tc.name, tc.expected, result)
			}
		})
	}
}
