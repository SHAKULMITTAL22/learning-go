// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-dbrx using AI Type  and AI Model 

ROOST_METHOD_HASH=isPowerOfTwo_fe7a80abf8
ROOST_METHOD_SIG_HASH=isPowerOfTwo_a909b954a6

Here are several test scenarios for the `isPowerOfTwo` function, covering normal operations, edge cases, and potential pitfalls:

---

Scenario 1: Test with a Small Power of Two

Details:
  Description: Verify that the function correctly identifies a small positive integer that is a power of two.
  Execution:
    Arrange: Choose a small number like 8, which is a power of two.
    Act: Call `isPowerOfTwo(8)`.
    Assert: Check that the result is `true`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Since 8 is 2^3, it should return `true`.
    Discuss the importance of the test in relation to the application's behavior or business requirements: This test ensures that the function correctly identifies powers of two, a fundamental requirement for its correctness.

---

Scenario 2: Test with a Small Non-Power of Two

Details:
  Description: Verify that the function correctly identifies a small positive integer that is not a power of two.
  Execution:
    Arrange: Choose a small number like 3, which is not a power of two.
    Act: Call `isPowerOfTwo(3)`.
    Assert: Check that the result is `false`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Since 3 is not a power of two, it should return `false`.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures the function does not falsely identify non-powers of two as powers of two.

---

Scenario 3: Test with One

Details:
  Description: Verify the function's behavior with the number 1, which is a special case since it's 2^0.
  Execution:
    Arrange: Use the number 1.
    Act: Call `isPowerOfTwo(1)`.
    Assert: Check that the result is `false`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: The function is expected to return `false` for numbers less than 2 based on the implementation.
    Discuss the importance of the test in relation to the application's behavior or business requirements: This test verifies handling of edge cases, ensuring the function adheres to its defined behavior.

---

Scenario 4: Test with Zero

Details:
  Description: Check the function's behavior with zero, an edge case.
  Execution:
    Arrange: Use the number 0.
    Act: Call `isPowerOfTwo(0)`.
    Assert: Check that the result is `false`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Zero is not a power of two, and the function should return `false`.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Validates that the function handles edge cases correctly.

---

Scenario 5: Test with Negative Number

Details:
  Description: Ensure the function handles negative numbers correctly.
  Execution:
    Arrange: Use a negative number like -8.
    Act: Call `isPowerOfTwo(-8)`.
    Assert: Check that the result is `false`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Negative numbers cannot be powers of two, so it should return `false`.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures robustness against invalid input values.

---

Scenario 6: Test with Large Power of Two

Details:
  Description: Verify the function's capability to handle large powers of two.
  Execution:
    Arrange: Use a large power of two, such as 1024 (2^10).
    Act: Call `isPowerOfTwo(1024)`.
    Assert: Check that the result is `true`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: Since 1024 is a power of two, it should return `true`.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures that the function can handle larger inputs accurately.

---

Scenario 7: Test with Large Non-Power of Two

Details:
  Description: Verify the function's performance with large non-power of two numbers.
  Execution:
    Arrange: Use a large non-power of two, such as 1000.
    Act: Call `isPowerOfTwo(1000)`.
    Assert: Check that the result is `false`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result: 1000 is not a power of two, so it should return `false`.
    Discuss the importance of the test in relation to the application's behavior or business requirements: Ensures that the function does not incorrectly classify large numbers.

---

These scenarios cover a comprehensive set of cases, ensuring the function behaves correctly across a variety of inputs.
*/

// ********RoostGPT********
package isPowerOfTwo

import (
	"testing"
)

// isPowerOfTwo checks if a given number is a power of two.
func TestIsPowerOfTwo(t *testing.T) {
	tests := []struct {
		name     string
		input    int
		expected bool
	}{
		{
			name:     "Small Power of Two",
			input:    8,
			expected: true,
		},
		{
			name:     "Small Non-Power of Two",
			input:    3,
			expected: false,
		},
		{
			name:     "Number One",
			input:    1,
			expected: true, // Number one should be considered a power of two (2^0)
		},
		{
			name:     "Zero",
			input:    0,
			expected: false,
		},
		{
			name:     "Negative Number",
			input:    -8,
			expected: false,
		},
		{
			name:     "Large Power of Two",
			input:    1024,
			expected: true,
		},
		{
			name:     "Large Non-Power of Two",
			input:    1000,
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Log("Running test:", tt.name)
			result := isPowerOfTwo(tt.input)
			if result != tt.expected {
				t.Errorf("isPowerOfTwo(%d) = %v; expected %v", tt.input, result, tt.expected)
			} else {
				t.Logf("Success: isPowerOfTwo(%d) = %v", tt.input, result)
			}
		})
	}
}
