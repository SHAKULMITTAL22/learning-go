// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-dbrx using AI Type  and AI Model 

ROOST_METHOD_HASH=fastPowering_860ba92ce3
ROOST_METHOD_SIG_HASH=fastPowering_be2e642e07

### Scenario 1: Test Fast Powering with Positive Integer Power

Details:
  Description: This test checks the functionality of the `fastPowering` function when raising a positive base to a positive integer power.
Execution:
  Arrange: Choose a base, such as 2, and a power, such as 10.
  Act: Invoke the `fastPowering` function with the base 2 and power 10.
  Assert: Verify that the result is 1024, as 2^10 equals 1024.
Validation:
  The assertion checks if the result of the function matches the mathematically expected output for 2 raised to the 10th power. This test is crucial for validating that the function correctly handles typical cases of exponentiation.

### Scenario 2: Test Fast Powering with Zero Power

Details:
  Description: This test verifies that any non-zero base raised to the power of zero returns 1, as per the mathematical rule \(x^0 = 1\).
Execution:
  Arrange: Select a base, such as 5.
  Act: Call `fastPowering` with the base 5 and power 0.
  Assert: Confirm that the result is 1.
Validation:
  The test checks the correct implementation of the edge case where the power is zero. Ensuring that the function returns 1 for any base with zero power is essential for accuracy in mathematical computations.

### Scenario 3: Test Fast Powering with Negative Power

Details:
  Description: This test ensures that the function can correctly compute cases where the power is negative, which implies taking the reciprocal of the base raised to the absolute value of the power.
Execution:
  Arrange: Choose a base, such as 2, and a negative power, such as -2.
  Act: Execute `fastPowering` with base 2 and power -2.
  Assert: The result should be 0.25, as 2^-2 equals 0.25.
Validation:
  The test is vital for confirming that the function handles negative powers correctly, which involves reciprocal operations and is commonly used in scientific calculations.

### Scenario 4: Test Fast Powering with Fractional Base

Details:
  Description: Evaluate the function's response to fractional bases raised to an integer power.
Execution:
  Arrange: Set a fractional base, such as 0.5, and a power, such as 3.
  Act: Run `fastPowering` with base 0.5 and power 3.
  Assert: Expect the output to be 0.125, since \(0.5^3 = 0.125\).
Validation:
  This scenario tests the function's ability to handle fractional bases, which is important for applications requiring precision with fractional numbers.

### Scenario 5: Test Fast Powering with Base Zero and Positive Power

Details:
  Description: Check the behavior when the base is zero and the power is a positive integer.
Execution:
  Arrange: Use a base of 0 and a positive power, such as 5.
  Act: Invoke `fastPowering` with base 0 and power 5.
  Assert: The result should be 0, as \(0^5 = 0\).
Validation:
  This test ensures that the function correctly handles the case of zero raised to any positive integer, which should always result in zero, critical for correctness in zero-centric calculations.

### Scenario 6: Test Fast Powering with One as Base

Details:
  Description: Test the scenario where the base is one, which should return one for any power.
Execution:
  Arrange: Set the base to 1 and choose any power, such as 999.
  Act: Call `fastPowering` with base 1 and power 999.
  Assert: The outcome should be 1, since \(1^{999} = 1\).
Validation:
  This scenario checks for the mathematical property that any number to the power of one remains unchanged. This property is fundamental and must be preserved in any correct implementation of exponentiation.
*/

// ********RoostGPT********
package FastPowering

import (
	"math"
	"testing"
)

func TestFastPowering(t *testing.T) {
	tests := []struct {
		name     string
		base     float64
		power    int
		expected float64
	}{
		{
			name:     "Positive Integer Power",
			base:     2,
			power:    10,
			expected: 1024,
		},
		{
			name:     "Zero Power",
			base:     5,
			power:    0,
			expected: 1,
		},
		{
			name:     "Negative Power",
			base:     2,
			power:    -2,
			expected: 0.25,
		},
		{
			name:     "Fractional Base",
			base:     0.5,
			power:    3,
			expected: 0.125,
		},
		{
			name:     "Base Zero and Positive Power",
			base:     0,
			power:    5,
			expected: 0,
		},
		{
			name:     "One as Base",
			base:     1,
			power:    999,
			expected: 1,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			result := fastPowering(tc.base, tc.power)
			t.Log("Testing case:", tc.name)
			t.Log("Base:", tc.base, "Power:", tc.power, "Expected:", tc.expected, "Got:", result)

			if math.Abs(result-tc.expected) > 1e-9 {
				t.Errorf("Failed %s: expected %v, got %v", tc.name, tc.expected, result)
			} else {
				t.Logf("Passed %s", tc.name)
			}
		})
	}
}

// Note: Ensure that the function fastPowering is implemented correctly to handle all edge cases, including negative powers.
