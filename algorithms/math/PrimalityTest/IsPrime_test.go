// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-dbrx using AI Type  and AI Model 

ROOST_METHOD_HASH=isPrime_117a72a056
ROOST_METHOD_SIG_HASH=isPrime_54426e0153

### Scenario 1: Test with a prime number

Details:
  Description: This test checks whether the function correctly identifies a prime number. A prime number has no divisors other than 1 and itself.
  Execution:
    Arrange: Choose a known prime number, e.g., 13.
    Act: Call the `isPrime` function with the number 13.
    Assert: The function should return `true`.
  Validation:
    The assertion checks if the function returns `true` for a prime number. This test is crucial as it validates that the function can correctly identify basic prime numbers, which is its fundamental purpose.

### Scenario 2: Test with a non-prime number

Details:
  Description: This test checks whether the function correctly identifies a non-prime number. A non-prime number has at least one divisor other than 1 and itself.
  Execution:
    Arrange: Choose a known non-prime number, e.g., 10.
    Act: Call the `isPrime` function with the number 10.
    Assert: The function should return `false`.
  Validation:
    The assertion checks if the function returns `false` for a non-prime number. This test helps ensure the function's ability to distinguish non-prime numbers, crucial for its accuracy and reliability.

### Scenario 3: Test with the number one

Details:
  Description: This test verifies that the function correctly identifies the number 1 as non-prime.
  Execution:
    Arrange: Use the number 1.
    Act: Call the `isPrime` function with the number 1.
    Assert: The function should return `false`.
  Validation:
    Since 1 is not considered a prime number, the function should return `false`. This test is important to confirm that the function adheres to the mathematical definition of prime numbers.

### Scenario 4: Test with a negative number

Details:
  Description: This test checks the function's response when given a negative number. By definition, negative numbers cannot be prime.
  Execution:
    Arrange: Use a negative number, e.g., -3.
    Act: Call the `isPrime` function with -3.
    Assert: The function should return `false`.
  Validation:
    The assertion that the function returns `false` for negative numbers ensures that it correctly handles input values that are not capable of being prime, thus maintaining integrity across a broader range of inputs.

### Scenario 5: Test with the smallest prime number

Details:
  Description: This test ensures that the function can identify the smallest prime number, which is 2.
  Execution:
    Arrange: Use the number 2.
    Act: Call the `isPrime` function with the number 2.
    Assert: The function should return `true`.
  Validation:
    Since 2 is the smallest and only even prime number, it is essential that the function correctly identifies it as prime. This test checks the function's capability to handle edge cases involving the smallest limits of prime numbers.

### Scenario 6: Test with zero

Details:
  Description: Verify that the function recognizes zero as not a prime number.
  Execution:
    Arrange: Use the number 0.
    Act: Call the `isPrime` function with 0.
    Assert: The function should return `false`.
  Validation:
    Zero is universally not considered as a prime number. Ensuring that the function returns `false` for zero is necessary for it to comply with basic numeric properties and definitions. This test is fundamental to ensure the function's correct implementation of prime number identification.

These scenarios collectively ensure the function `isPrime` operates correctly across a typical range of inputs, including special cases like negative numbers, zero, and the smallest prime number.
*/

// ********RoostGPT********
package PrimalityTest

import (
	"math"
	"testing"
)

// TestIsPrime tests the isPrime function with various scenarios.
func TestIsPrime(t *testing.T) {
	tests := []struct {
		name     string
		number   int
		expected bool
	}{
		{"Test with a prime number", 13, true},
		{"Test with a non-prime number", 10, false},
		{"Test with the number one", 1, false},
		{"Test with a negative number", -3, false},
		{"Test with the smallest prime number", 2, true},
		{"Test with zero", 0, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := isPrime(tt.number)
			if result != tt.expected {
				t.Errorf("isPrime(%d) = %v, expected %v", tt.number, result, tt.expected)
			}
		})
	}
}

// isPrime determines if a number is a prime.
func isPrime(num int) bool {
	if num <= 1 {
		return false
	}
	if num == 2 {
		return true // Special case for the smallest prime number.
	}
	s := math.Sqrt(float64(num))
	for i := 2; i <= int(s); i++ {
		if num%i == 0 {
			return false
		}
	}
	return true
}
