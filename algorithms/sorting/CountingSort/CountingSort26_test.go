// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-test using AI Type  and AI Model 

ROOST_METHOD_HASH=countingSort_6ecd63b018
ROOST_METHOD_SIG_HASH=countingSort_11ced0d811

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: learning-go/algorithms/sorting/CountingSort/countingsort_test.go
Test Cases:
    [TestSelectionSort]

```markdown
Scenario 1: Sort an Already Sorted Array

Details:
  Description: This test checks if the `countingSort` function correctly handles an input array that is already sorted. The expected outcome is that the function returns the same sorted array without making unnecessary changes.
Execution:
  Arrange: Create a sorted array, such as `[1, 2, 3, 4, 5]`.
  Act: Pass the sorted array to the `countingSort` function.
  Assert: Verify that the returned array matches the input array.
Validation:
  This test confirms that the function doesn't alter an already sorted array. The loop logic should recognize that no changes are necessary, which is essential for efficiency.

Scenario 2: Sort a Reverse-Ordered Array

Details:
  Description: This scenario tests the function's ability to handle an array sorted in reverse order. The test expects the function to re-order the array into a standard sorted format.
Execution:
  Arrange: Create a reverse-ordered array, such as `[5, 4, 3, 2, 1]`.
  Act: Use `countingSort` to sort the reverse-ordered array.
  Assert: Verify that the resulting array is `[1, 2, 3, 4, 5]`.
Validation:
  The test ensures that counting sort can completely rearrange the elements to achieve a sorted result, confirming its core behavior.

Scenario 3: Handle an Array with Duplicate Elements

Details:
  Description: This test case examines how the function handles arrays containing duplicate values, ensuring it counts and places elements correctly.
Execution:
  Arrange: Prepare an input array with duplicates, such as `[2, 3, 2, 1, 3]`.
  Act: Call `countingSort` with this array.
  Assert: Check if the returned array is `[1, 2, 2, 3, 3]`.
Validation:
  The test verifies that duplicates are counted and placed without omission, validating the core counting mechanism of the function.

Scenario 4: Sort an Array with All Same Elements

Details:
  Description: This scenario checks if the function can handle an array where all elements are the same, ideally returning the same array.
Execution:
  Arrange: Create an input array where all elements are identical, such as `[4, 4, 4, 4]`.
  Act: Sort the array using `countingSort`.
  Assert: Validate that the array `[4, 4, 4, 4]` is returned.
Validation:
  This test proves that the counting array correctly processes identical values without any unnecessary changes, maintaining the integrity of the input.

Scenario 5: Sort an Empty Array

Details:
  Description: This test examines how the `countingSort` function handles an empty array, confirming it returns an empty array as expected without errors.
Execution:
  Arrange: Setup an empty array `[]`.
  Act: Pass it into `countingSort`.
  Assert: Ensure the function returns an empty array `[]`.
Validation:
  The test is crucial for ensuring robustness, confirming the function does not attempt invalid operations on an empty input and returns a valid result.

Scenario 6: Large Elements in Array

Details:
  Description: This scenario tests how the function performs when handling elements with large values and whether it adapts the counting array accordingly.
Execution:
  Arrange: Create an array with elements containing large values, such as `[1000, 999, 998]`.
  Act: Run `countingSort` on this array.
  Assert: Verify that the returned array is `[998, 999, 1000]`.
Validation:
  The test validates that the function correctly determines the range of the counting array to accommodate larger numbers, which is critical for generalizing the solution to varied inputs.

Scenario 7: Single Element Array

Details:
  Description: This test verifies the function's behavior when given an array with a single element, ensuring it correctly handles minimal input.
Execution:
  Arrange: Prepare a single-element array, such as `[42]`.
  Act: Pass this array to `countingSort`.
  Assert: Confirm that `[42]` is the output with no alteration.
Validation:
  The test establishes that the function recognizes trivial cases where sorting is unnecessary, maintaining correct output without issues.

Scenario 8: Array with Negative Numbers

Details:
  Description: This scenario is included to determine if the function can effectively deal with negative inputs, though typically not handled by counting sort in its simplest form.
Execution:
  Arrange: Prepare an array with negative numbers, e.g., `[-2, -1, -3]`.
  Act: Attempt to sort the array using `countingSort`.
  Assert: Check how the function returns results or errors due to negatives.
Validation:
  Although counting sort is generally used for non-negative integers, exploring this test can expose the need for preprocessing steps in applications where negative numbers are involved.
```

These scenarios collectively ensure comprehensive testing across different potential input conditions and edge cases for the `countingSort` function.
*/

// ********RoostGPT********
package CountingSort

import (
	"bytes"
	"fmt"
	"os"
	"testing"
	"errors"
)

// Counting sort adjusted to handle errors for negative numbers
func countingSort(arr []int) ([]int, error) {
	for _, num := range arr {
		if num < 0 {
			return nil, errors.New("negative numbers not supported")
		}
	}
	k := getCountArrayLength(arr)
	count := make([]int, k)
	for i := 0; i < len(arr); i++ {
		count[arr[i]] += 1
	}
	for i, j := 0, 0; i < k; i++ {
		for {
			if count[i] > 0 {
				arr[j] = i
				j += 1
				count[i] -= 1
				continue
			}
			break
		}
	}
	return arr, nil
}

func TestCountingSort26(t *testing.T) {
	type testCase struct {
		name         string
		input        []int
		expected     []int
		expectError  bool
		expectedLogs string
	}

	tests := []testCase{
		{
			name:         "Already Sorted Array",
			input:        []int{1, 2, 3, 4, 5},
			expected:     []int{1, 2, 3, 4, 5},
			expectError:  false,
			expectedLogs: "Already Sorted Array case passed",
		},
		{
			name:         "Reverse Ordered Array",
			input:        []int{5, 4, 3, 2, 1},
			expected:     []int{1, 2, 3, 4, 5},
			expectError:  false,
			expectedLogs: "Reverse Ordered Array case passed",
		},
		{
			name:         "Array with Duplicates",
			input:        []int{2, 3, 2, 1, 3},
			expected:     []int{1, 2, 2, 3, 3},
			expectError:  false,
			expectedLogs: "Array with Duplicates case passed",
		},
		{
			name:         "All Same Elements",
			input:        []int{4, 4, 4, 4},
			expected:     []int{4, 4, 4, 4},
			expectError:  false,
			expectedLogs: "All Same Elements case passed",
		},
		{
			name:         "Empty Array",
			input:        []int{},
			expected:     []int{},
			expectError:  false,
			expectedLogs: "Empty Array case passed",
		},
		{
			name:         "Large Elements in Array",
			input:        []int{1000, 999, 998},
			expected:     []int{998, 999, 1000},
			expectError:  false,
			expectedLogs: "Large Elements in Array case passed",
		},
		{
			name:         "Single Element Array",
			input:        []int{42},
			expected:     []int{42},
			expectError:  false,
			expectedLogs: "Single Element Array case passed",
		},
		{
			name:         "Array with Negative Numbers", // Ensure to handle negative case in business logic 
			input:        []int{-2, -1, -3},
			expected:     nil,
			expectError:  true,
			expectedLogs: "Array with Negative Numbers case failed due to negative values",
		},
	}

	// Redirecting os.Stdout for testing output
	old := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			output, err := countingSort(tc.input)

			if tc.expectError {
				if err == nil {
					t.Errorf("Expected error for %v but got none", tc.name)
				} else {
					_, _ = fmt.Fprintln(w, tc.expectedLogs)
				}
			} else {
				if !equal(output, tc.expected) {
					t.Errorf("Test %v failed. Expected %v, got %v", tc.name, tc.expected, output)
				} else {
					_, _ = fmt.Fprintln(w, tc.expectedLogs)
				}
			}

			// Capture log output from os.Stdout
			w.Close()
			var buf bytes.Buffer
			fmt.Fscanf(r, "%s\n", &buf)

			// Check the output
			if buf.String() != tc.expectedLogs {
				t.Errorf("Expected log output not matched. Expected: %s, Got: %s", tc.expectedLogs, buf.String())
			}

			r.Close()
		})
	}

	// Reset os.Stdout
	os.Stdout = old
}

func equal(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func getCountArrayLength(arr []int) int {
	// Assumes all elements in arr are non-negative and valid
	max := 0
	for _, v := range arr {
		if v > max {
			max = v
		}
	}
	return max + 1
}
