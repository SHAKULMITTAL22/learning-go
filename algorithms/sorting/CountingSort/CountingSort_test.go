// ********RoostGPT********
/*
Test generated by RoostGPT for test go-test using AI Type  and AI Model 

ROOST_METHOD_HASH=countingSort_6ecd63b018
ROOST_METHOD_SIG_HASH=countingSort_11ced0d811

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: learning-go/algorithms/sorting/CountingSort/countingsort_test.go
Test Cases:
    [TestSelectionSort]

Based on the provided function `countingSort` and the requirements, here are several test scenarios for the function:

Scenario 1: Sort an array of positive integers

Details:
  Description: Test the basic functionality of countingSort with a small array of positive integers.
Execution:
  Arrange: Create an unsorted array of positive integers.
  Act: Call countingSort with the unsorted array.
  Assert: Verify that the returned array is sorted in ascending order.
Validation:
  This test ensures that the function correctly sorts a simple array of positive integers, which is the core functionality of the counting sort algorithm.

Scenario 2: Sort an array with duplicate elements

Details:
  Description: Verify that countingSort correctly handles arrays with duplicate elements.
Execution:
  Arrange: Create an unsorted array with multiple occurrences of the same integers.
  Act: Call countingSort with the array containing duplicates.
  Assert: Check that the returned array is sorted and contains all duplicates in the correct order.
Validation:
  This test is important to ensure that the function correctly handles and preserves duplicate elements, which is a common scenario in real-world data.

Scenario 3: Sort an array with zero as an element

Details:
  Description: Test the function's ability to handle zero as an element in the input array.
Execution:
  Arrange: Create an unsorted array that includes zero as one of its elements.
  Act: Call countingSort with this array.
  Assert: Verify that zero is correctly placed in the sorted output array.
Validation:
  This test is crucial because zero is a special case that might be treated differently in some implementations, and we need to ensure it's handled correctly.

Scenario 4: Sort an array with a single element

Details:
  Description: Verify the behavior of countingSort when given an array with only one element.
Execution:
  Arrange: Create an array with a single integer element.
  Act: Call countingSort with this single-element array.
  Assert: Check that the returned array is identical to the input array.
Validation:
  This edge case tests the function's ability to handle minimal input correctly without unnecessary operations.

Scenario 5: Sort an empty array

Details:
  Description: Test the function's behavior when given an empty array as input.
Execution:
  Arrange: Create an empty integer array.
  Act: Call countingSort with the empty array.
  Assert: Verify that the function returns an empty array.
Validation:
  This edge case ensures that the function handles empty input gracefully without causing errors or unexpected behavior.

Scenario 6: Sort an array with large range of values

Details:
  Description: Test the function's performance and correctness with a wide range of integer values.
Execution:
  Arrange: Create an array with integers ranging from very small to very large values.
  Act: Call countingSort with this wide-range array.
  Assert: Verify that all elements are correctly sorted in the output array.
Validation:
  This test checks the function's ability to handle a large range of values, which is important for real-world applications where data can vary widely.

Scenario 7: Sort an array with negative numbers (Error case)

Details:
  Description: Verify the function's behavior when given an array containing negative numbers.
Execution:
  Arrange: Create an array that includes negative integers.
  Act: Call countingSort with this array containing negative numbers.
  Assert: Check for appropriate error handling or panic.
Validation:
  This test is important to verify how the function handles invalid input, as the current implementation doesn't support negative numbers.

These scenarios cover various aspects of the countingSort function, including normal operation, edge cases, and potential error conditions. They help ensure the robustness and correctness of the implementation across different input types and sizes.
*/

// ********RoostGPT********
package countingsort

import (
	"reflect"
	"testing"
)

func TestCountingSort(t *testing.T) {
	tests := []struct {
		name     string
		input    []int
		expected []int
	}{
		{
			name:     "Sort an array of positive integers",
			input:    []int{4, 2, 2, 8, 3, 3, 1},
			expected: []int{1, 2, 2, 3, 3, 4, 8},
		},
		{
			name:     "Sort an array with duplicate elements",
			input:    []int{5, 2, 5, 1, 2, 3, 5},
			expected: []int{1, 2, 2, 3, 5, 5, 5},
		},
		{
			name:     "Sort an array with zero as an element",
			input:    []int{3, 0, 2, 5, 1, 0, 4},
			expected: []int{0, 0, 1, 2, 3, 4, 5},
		},
		{
			name:     "Sort an array with a single element",
			input:    []int{42},
			expected: []int{42},
		},
		{
			name:     "Sort an empty array",
			input:    []int{},
			expected: []int{},
		},
		{
			name:     "Sort an array with large range of values",
			input:    []int{1000, 1, 500, 2, 250, 3},
			expected: []int{1, 2, 3, 250, 500, 1000},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a copy of the input to ensure the original slice is not modified
			input := make([]int, len(tt.input))
			copy(input, tt.input)

			result := countingSort(input)
			if !reflect.DeepEqual(result, tt.expected) {
				t.Errorf("countingSort() = %v, want %v", result, tt.expected)
			}

			// Check if the original input was modified (it shouldn't be)
			if !reflect.DeepEqual(input, tt.input) {
				t.Errorf("Input was modified: got %v, want %v", input, tt.input)
			}
		})
	}
}

func TestCountingSortWithNegativeNumbers(t *testing.T) {
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("The code did not panic")
		}
	}()

	input := []int{3, -1, 2, 5, -4, 0}
	countingSort(input)
}
