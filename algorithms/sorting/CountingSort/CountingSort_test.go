// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-1 using AI Type  and AI Model 

ROOST_METHOD_HASH=countingSort_6ecd63b018
ROOST_METHOD_SIG_HASH=countingSort_11ced0d811

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: learning-go/algorithms/sorting/CountingSort/countingsort_test.go
Test Cases:
    [TestSelectionSort]

Based on the provided function and requirements, here are several test scenarios for the `countingSort` function:

Scenario 1: Sort an array of positive integers

Details:
  Description: Test the basic functionality of the counting sort algorithm with a small array of positive integers.
Execution:
  Arrange: Create an unsorted array of positive integers.
  Act: Call the countingSort function with the unsorted array.
  Assert: Verify that the returned array is sorted in ascending order.
Validation:
  This test ensures that the function correctly sorts a simple array of positive integers, which is the core functionality of the counting sort algorithm.

Scenario 2: Sort an array with duplicate elements

Details:
  Description: Verify that the function correctly handles arrays containing duplicate elements.
Execution:
  Arrange: Create an unsorted array with multiple occurrences of the same integers.
  Act: Call the countingSort function with this array.
  Assert: Check that the returned array is sorted and contains all the original elements, including duplicates.
Validation:
  This test is important to ensure that the function correctly handles duplicate elements, which is a common scenario in real-world data.

Scenario 3: Sort an array with a single element

Details:
  Description: Test the function's behavior with an array containing only one element.
Execution:
  Arrange: Create an array with a single integer.
  Act: Pass this array to the countingSort function.
  Assert: Verify that the returned array is identical to the input array.
Validation:
  This edge case tests the function's ability to handle minimal input correctly without introducing errors.

Scenario 4: Sort an empty array

Details:
  Description: Verify the function's behavior when given an empty array as input.
Execution:
  Arrange: Create an empty integer array.
  Act: Call the countingSort function with the empty array.
  Assert: Check that the function returns an empty array.
Validation:
  This edge case ensures that the function handles empty input gracefully without causing errors or unexpected behavior.

Scenario 5: Sort an array with all elements being zero

Details:
  Description: Test the function's performance with an array where all elements are zero.
Execution:
  Arrange: Create an array filled with zeros.
  Act: Pass this array to the countingSort function.
  Assert: Verify that the returned array is identical to the input array.
Validation:
  This scenario tests the function's ability to handle a special case where all elements are the same and the minimum possible value.

Scenario 6: Sort a large array

Details:
  Description: Test the function's performance and correctness with a large input array.
Execution:
  Arrange: Generate a large array (e.g., 100,000 elements) with random positive integers.
  Act: Call the countingSort function with this large array.
  Assert: Verify that the returned array is correctly sorted.
Validation:
  This test checks the function's efficiency and correctness when dealing with large datasets, which is crucial for real-world applications.

Scenario 7: Verify stability of the sort

Details:
  Description: Ensure that the sorting algorithm maintains the relative order of equal elements.
Execution:
  Arrange: Create an array of custom structs with an integer key and a string value. Include multiple structs with the same integer key.
  Act: Sort the array using a modified countingSort that works with the custom struct.
  Assert: Check that elements with equal keys maintain their original relative order in the sorted array.
Validation:
  This test is important to verify that the counting sort implementation is stable, which can be a requirement in certain applications where the original order of equal elements matters.

These scenarios cover a range of cases including normal operation, edge cases, and performance considerations for the `countingSort` function. They aim to thoroughly test the function's correctness and robustness under various conditions.
*/

// ********RoostGPT********
package countingsort

import (
	"reflect"
	"testing"
)

func TestCountingSort(t *testing.T) {
	tests := []struct {
		name     string
		input    []int
		expected []int
	}{
		{
			name:     "Sort an array of positive integers",
			input:    []int{4, 2, 2, 8, 3, 3, 1},
			expected: []int{1, 2, 2, 3, 3, 4, 8},
		},
		{
			name:     "Sort an array with duplicate elements",
			input:    []int{5, 2, 5, 1, 2, 3, 5},
			expected: []int{1, 2, 2, 3, 5, 5, 5},
		},
		{
			name:     "Sort an array with a single element",
			input:    []int{42},
			expected: []int{42},
		},
		{
			name:     "Sort an empty array",
			input:    []int{},
			expected: []int{},
		},
		{
			name:     "Sort an array with all elements being zero",
			input:    []int{0, 0, 0, 0, 0},
			expected: []int{0, 0, 0, 0, 0},
		},
		{
			name:     "Sort a large array",
			input:    generateLargeArray(100000),
			expected: generateSortedArray(100000),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := countingSort(tt.input)
			if !reflect.DeepEqual(result, tt.expected) {
				t.Errorf("countingSort() = %v, want %v", result, tt.expected)
			}
		})
	}
}

// Helper function to generate a large array with random positive integers
func generateLargeArray(size int) []int {
	arr := make([]int, size)
	for i := 0; i < size; i++ {
		arr[i] = i % 1000 // Using modulo to limit the range of values
	}
	return arr
}

// Helper function to generate a sorted array
func generateSortedArray(size int) []int {
	arr := make([]int, size)
	for i := 0; i < size; i++ {
		arr[i] = i % 1000
	}
	return arr
}

// TestCountingSortStability verifies the stability of the counting sort algorithm
func TestCountingSortStability(t *testing.T) {
	type element struct {
		key   int
		value string
	}

	input := []element{
		{2, "a"},
		{1, "b"},
		{2, "c"},
		{1, "d"},
		{3, "e"},
	}

	expected := []element{
		{1, "b"},
		{1, "d"},
		{2, "a"},
		{2, "c"},
		{3, "e"},
	}

	// Modify countingSort to work with custom structs
	result := countingSortStable(input)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("countingSortStable() = %v, want %v", result, expected)
	}
}

// countingSortStable is a modified version of countingSort that works with custom structs
func countingSortStable(arr []element) []element {
	if len(arr) == 0 {
		return arr
	}

	// Find the maximum key
	max := arr[0].key
	for _, e := range arr {
		if e.key > max {
			max = e.key
		}
	}

	// Create count array
	count := make([]int, max+1)
	for _, e := range arr {
		count[e.key]++
	}

	// Calculate cumulative count
	for i := 1; i <= max; i++ {
		count[i] += count[i-1]
	}

	// Build the output array
	output := make([]element, len(arr))
	for i := len(arr) - 1; i >= 0; i-- {
		output[count[arr[i].key]-1] = arr[i]
		count[arr[i].key]--
	}

	return output
}
