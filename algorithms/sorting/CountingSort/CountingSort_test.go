// ********RoostGPT********
/*
Test generated by RoostGPT for test go-test using AI Type  and AI Model 

ROOST_METHOD_HASH=countingSort_6ecd63b018
ROOST_METHOD_SIG_HASH=countingSort_11ced0d811

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: learning-go/algorithms/sorting/CountingSort/countingsort_test.go
Test Cases:
    [TestSelectionSort]

Based on the provided function `countingSort` and the requirements, here are several test scenarios for it:

Scenario 1: Sort an array with positive integers

Details:
  Description: Test the basic functionality of countingSort with an array containing positive integers.
Execution:
  Arrange: Prepare an unsorted array of positive integers.
  Act: Call countingSort with the prepared array.
  Assert: Verify that the returned array is sorted in ascending order.
Validation:
  This test ensures the core functionality of the sorting algorithm works correctly for the most common use case. It's crucial to validate that the function can handle a basic scenario with positive integers.

Scenario 2: Sort an array with duplicate elements

Details:
  Description: Verify that countingSort correctly handles arrays with duplicate elements.
Execution:
  Arrange: Create an array with multiple occurrences of the same integer.
  Act: Pass the array to countingSort.
  Assert: Check that the returned array is sorted and contains all duplicates in the correct order.
Validation:
  This test is important to ensure the algorithm correctly counts and places duplicate elements, which is a key aspect of counting sort.

Scenario 3: Sort an array with a single element

Details:
  Description: Test the behavior of countingSort when given an array with only one element.
Execution:
  Arrange: Create an array with a single integer.
  Act: Call countingSort with this array.
  Assert: Verify that the returned array is identical to the input array.
Validation:
  This edge case tests the function's ability to handle minimal input correctly, ensuring it doesn't introduce errors for trivial cases.

Scenario 4: Sort an empty array

Details:
  Description: Verify that countingSort handles an empty array input correctly.
Execution:
  Arrange: Create an empty integer array.
  Act: Pass the empty array to countingSort.
  Assert: Check that the function returns an empty array.
Validation:
  Testing with an empty array is crucial to ensure the function doesn't crash or produce unexpected results when given no elements to sort.

Scenario 5: Sort an array with all elements being zero

Details:
  Description: Test countingSort's behavior when all elements in the input array are zero.
Execution:
  Arrange: Create an array filled with zeros.
  Act: Call countingSort with this array.
  Assert: Verify that the returned array is identical to the input array, containing all zeros.
Validation:
  This scenario tests the function's ability to handle a special case where all elements are the same and at the lower bound of the counting array.

Scenario 6: Sort an array with large range of values

Details:
  Description: Verify that countingSort can handle arrays with a large range between the minimum and maximum values.
Execution:
  Arrange: Create an array with integers ranging from 0 to a very large number (e.g., 1,000,000).
  Act: Pass this array to countingSort.
  Assert: Check that the returned array is correctly sorted.
Validation:
  This test ensures that the function can handle inputs with a large range of values, which affects the size of the counting array and tests the efficiency of the algorithm.

Scenario 7: Sort an array with negative numbers (if supported)

Details:
  Description: Test if countingSort can handle negative integers correctly.
Execution:
  Arrange: Prepare an array containing both positive and negative integers.
  Act: Attempt to sort this array using countingSort.
  Assert: If negative numbers are supported, verify the array is sorted correctly. If not, check for appropriate error handling.
Validation:
  This test explores the function's behavior with negative numbers, which may not be supported by the current implementation. It's important to understand and document this limitation or capability.

These scenarios cover a range of normal operations, edge cases, and potential limitations of the countingSort function. They aim to thoroughly test the function's correctness and robustness under various conditions.
*/

// ********RoostGPT********
package countingsort

import (
	"reflect"
	"testing"
)

func TestCountingSort(t *testing.T) {
	tests := []struct {
		name     string
		input    []int
		expected []int
	}{
		{
			name:     "Sort array with positive integers",
			input:    []int{4, 2, 2, 8, 3, 3, 1},
			expected: []int{1, 2, 2, 3, 3, 4, 8},
		},
		{
			name:     "Sort array with duplicate elements",
			input:    []int{5, 5, 3, 2, 1, 5, 4, 3},
			expected: []int{1, 2, 3, 3, 4, 5, 5, 5},
		},
		{
			name:     "Sort array with single element",
			input:    []int{42},
			expected: []int{42},
		},
		{
			name:     "Sort empty array",
			input:    []int{},
			expected: []int{},
		},
		{
			name:     "Sort array with all elements being zero",
			input:    []int{0, 0, 0, 0, 0},
			expected: []int{0, 0, 0, 0, 0},
		},
		{
			name:     "Sort array with large range of values",
			input:    []int{1000000, 0, 500000, 250000, 750000},
			expected: []int{0, 250000, 500000, 750000, 1000000},
		},
		// Note: Negative numbers are not supported in the current implementation
		// Uncomment the following test case if negative numbers support is added
		// {
		// 	name:     "Sort array with negative numbers",
		// 	input:    []int{-3, 0, 2, -1, 1, -2},
		// 	expected: []int{-3, -2, -1, 0, 1, 2},
		// },
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := countingSort(tt.input)
			if !reflect.DeepEqual(result, tt.expected) {
				t.Errorf("countingSort() = %v, want %v", result, tt.expected)
			}
		})
	}
}
