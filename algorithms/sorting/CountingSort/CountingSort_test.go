// ********RoostGPT********
/*
Test generated by RoostGPT for test go-test using AI Type  and AI Model 

ROOST_METHOD_HASH=countingSort_6ecd63b018
ROOST_METHOD_SIG_HASH=countingSort_11ced0d811

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: learning-go/algorithms/sorting/CountingSort/countingsort_test.go
Test Cases:
    [TestSelectionSort]

Based on the provided function `countingSort`, here are several test scenarios to consider:

```
Scenario 1: Sort an array with positive integers

Details:
  Description: Test the basic functionality of countingSort with an array containing only positive integers.
Execution:
  Arrange: Create an unsorted array of positive integers.
  Act: Call countingSort with the unsorted array.
  Assert: Verify that the returned array is sorted in ascending order.
Validation:
  This test ensures that the function correctly sorts a basic array of positive integers, which is the core functionality of the counting sort algorithm.

Scenario 2: Sort an array with duplicate elements

Details:
  Description: Verify that countingSort correctly handles arrays with duplicate elements.
Execution:
  Arrange: Create an unsorted array with multiple occurrences of the same integer.
  Act: Call countingSort with the unsorted array.
  Assert: Check that the returned array is sorted and contains all duplicate elements in the correct order.
Validation:
  This test is important to ensure that the algorithm correctly counts and places duplicate elements, which is a key aspect of the counting sort method.

Scenario 3: Sort an array with a single element

Details:
  Description: Test the behavior of countingSort when given an array with only one element.
Execution:
  Arrange: Create an array with a single integer.
  Act: Call countingSort with this single-element array.
  Assert: Verify that the returned array is identical to the input array.
Validation:
  This edge case test ensures that the function handles minimal input correctly without introducing errors.

Scenario 4: Sort an empty array

Details:
  Description: Verify that countingSort correctly handles an empty array input.
Execution:
  Arrange: Create an empty integer array.
  Act: Call countingSort with the empty array.
  Assert: Check that the function returns an empty array.
Validation:
  This edge case test is crucial to ensure that the function doesn't crash or produce unexpected results when given an empty input.

Scenario 5: Sort an array with all elements being zero

Details:
  Description: Test the behavior of countingSort when all elements in the input array are zero.
Execution:
  Arrange: Create an array filled with zeros.
  Act: Call countingSort with this array.
  Assert: Verify that the returned array is identical to the input array.
Validation:
  This test checks how the function handles an edge case where all elements are the same and at the lower bound of the counting array.

Scenario 6: Sort an array with large range of values

Details:
  Description: Verify that countingSort can handle arrays with a large range between the minimum and maximum values.
Execution:
  Arrange: Create an array with integers ranging from 0 to a very large number.
  Act: Call countingSort with this array.
  Assert: Check that the returned array is correctly sorted.
Validation:
  This test ensures that the function can handle inputs with a large range, which affects the size of the counting array and overall performance.

Scenario 7: Verify stability of the sort

Details:
  Description: Test that countingSort maintains the relative order of equal elements (stability property).
Execution:
  Arrange: Create an array with multiple occurrences of the same value, but with distinguishable properties (e.g., using structs).
  Act: Call countingSort with this array.
  Assert: Verify that elements with equal sort keys maintain their original relative order.
Validation:
  This test is important to confirm that the sorting algorithm is stable, which can be crucial for certain applications.
```

These scenarios cover a range of normal operations, edge cases, and important properties of the counting sort algorithm. They aim to thoroughly test the `countingSort` function's correctness and robustness.
*/

// ********RoostGPT********
package countingsort

import (
	"reflect"
	"testing"
)

func TestCountingSort(t *testing.T) {
	tests := []struct {
		name     string
		input    []int
		expected []int
	}{
		{
			name:     "Sort array with positive integers",
			input:    []int{4, 2, 2, 8, 3, 3, 1},
			expected: []int{1, 2, 2, 3, 3, 4, 8},
		},
		{
			name:     "Sort array with duplicate elements",
			input:    []int{5, 2, 5, 1, 2, 5, 3},
			expected: []int{1, 2, 2, 3, 5, 5, 5},
		},
		{
			name:     "Sort array with a single element",
			input:    []int{42},
			expected: []int{42},
		},
		{
			name:     "Sort empty array",
			input:    []int{},
			expected: []int{},
		},
		{
			name:     "Sort array with all elements being zero",
			input:    []int{0, 0, 0, 0, 0},
			expected: []int{0, 0, 0, 0, 0},
		},
		{
			name:     "Sort array with large range of values",
			input:    []int{1000000, 0, 500000, 1, 999999},
			expected: []int{0, 1, 500000, 999999, 1000000},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := countingSort(tt.input)
			if !reflect.DeepEqual(result, tt.expected) {
				t.Errorf("countingSort() = %v, want %v", result, tt.expected)
			}
		})
	}
}

// TestCountingSortStability verifies the stability of the sorting algorithm
func TestCountingSortStability(t *testing.T) {
	type item struct {
		value int
		index int
	}

	input := []item{
		{value: 3, index: 0},
		{value: 1, index: 1},
		{value: 3, index: 2},
		{value: 2, index: 3},
		{value: 1, index: 4},
	}

	expected := []item{
		{value: 1, index: 1},
		{value: 1, index: 4},
		{value: 2, index: 3},
		{value: 3, index: 0},
		{value: 3, index: 2},
	}

	// Convert input to []int for countingSort
	intInput := make([]int, len(input))
	for i, v := range input {
		intInput[i] = v.value
	}

	sortedInts := countingSort(intInput)

	// Reconstruct sorted items
	sortedItems := make([]item, len(input))
	usedIndices := make(map[int]bool)

	for i, v := range sortedInts {
		for j, orig := range input {
			if orig.value == v && !usedIndices[j] {
				sortedItems[i] = orig
				usedIndices[j] = true
				break
			}
		}
	}

	if !reflect.DeepEqual(sortedItems, expected) {
		t.Errorf("countingSort() is not stable. Got %v, want %v", sortedItems, expected)
	}
}
