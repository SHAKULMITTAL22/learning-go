// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-test using AI Type Azure Open AI and AI Model gpt-4o-standard

ROOST_METHOD_HASH=binarySearch_5149337a0e
ROOST_METHOD_SIG_HASH=binarySearch_7d22ad2576

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: learning-go/algorithms/search/BinarySearch/binarysearch_test.go
Test Cases:
    [TestBinarySearch]

Note: Only generate test cases based on the given scenarios,do not generate test cases other than these scenarios
Scenario 1: Validate Empty Email String
Scenario 2: Validate Maximum Length Email
*/

// ********RoostGPT********
package BinarySearch

import (
	"bytes"
	"fmt"
	"os"
	"testing"
)

func Testbinarysearch501(t *testing.T) {
	type testCase struct {
		description string
		arr         []int
		query       int
		expected    int
	}

	testCases := []testCase{
		{
			description: "Empty array",
			arr:         []int{},
			query:       5,
			expected:    -1,
		},
		{
			description: "Single element array, element present",
			arr:         []int{5},
			query:       5,
			expected:    0,
		},
		{
			description: "Single element array, element absent",
			arr:         []int{5},
			query:       3,
			expected:    -1,
		},
		{
			description: "Multiple elements, query at start",
			arr:         []int{1, 2, 3, 4, 5},
			query:       1,
			expected:    0,
		},
		{
			description: "Multiple elements, query at end",
			arr:         []int{1, 2, 3, 4, 5},
			query:       5,
			expected:    4,
		},
		{
			description: "Multiple elements, query in middle",
			arr:         []int{1, 2, 3, 4, 5},
			query:       3,
			expected:    2,
		},
		{
			description: "Element not present",
			arr:         []int{1, 2, 3, 4, 5},
			query:       6,
			expected:    -1,
		},
		// TODO: Add more edge case scenarios as they arise
	}

	for _, tc := range testCases {
		t.Run(tc.description, func(t *testing.T) {
			// Prepare to capture stdout if necessary
			old := os.Stdout
			r, w, _ := os.Pipe()
			os.Stdout = w

			// Call the function
			result := binarySearch(tc.arr, tc.query)

			// Capture stdout
			w.Close()
			var buf bytes.Buffer
			fmt.Fscanf(r, "%s", &buf)
			os.Stdout = old

			// Log and compare the result
			t.Logf("Running test: %s", tc.description)
			if result != tc.expected {
				t.Errorf("Failed %s: expected %d, got %d", tc.description, tc.expected, result)
				t.Logf("Output was: %s", buf.String())
			} else {
				t.Logf("Success: %s", tc.description)
			}
		})
	}
}
