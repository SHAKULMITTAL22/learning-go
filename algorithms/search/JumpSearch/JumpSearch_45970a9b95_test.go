// Test generated by RoostGPT for test math-go using AI Type Open AI and AI Model gpt-4

package JumpSearch

import (
	"math"
	"testing"
)

func TestJumpSearch_45970a9b95(t *testing.T) {
	// Test case 1: Normal scenario
	arr1 := []int{0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
	query1 := 55
	expected1 := 10
	result1 := JumpSearch(arr1, query1)
	if result1 != expected1 {
		t.Errorf("Test case 1 failed: got %d, expected %d", result1, expected1)
	} else {
		t.Logf("Test case 1 successful: got %d, expected %d", result1, expected1)
	}

	// Test case 2: Element not found
	arr2 := []int{0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}
	query2 := 100
	expected2 := -1
	result2 := JumpSearch(arr2, query2)
	if result2 != expected2 {
		t.Errorf("Test case 2 failed: got %d, expected %d", result2, expected2)
	} else {
		t.Logf("Test case 2 successful: got %d, expected %d", result2, expected2)
	}

	// Test case 3: Empty array
	arr3 := []int{}
	query3 := 1
	expected3 := -1
	result3 := JumpSearch(arr3, query3)
	if result3 != expected3 {
		t.Errorf("Test case 3 failed: got %d, expected %d", result3, expected3)
	} else {
		t.Logf("Test case 3 successful: got %d, expected %d", result3, expected3)
	}
}

func JumpSearch(arr []int, query int) int {
	size := len(arr)
	step := int(math.Sqrt(float64(size)))
	prev := 0

	// We can't find anything in empty array
	if size == 0 {
		return -1
	}

	// Finding the block where element is present (if it is present)
	for arr[int(math.Min(float64(step), float64(size)))-1] < query {
		prev = step
		step += int(math.Sqrt(float64(size)))
		if prev >= size {
			return -1
		}
	}

	// Doing a linear search for x in block beginning with prev
	for arr[prev] < query {
		prev++

		// If we reached next block or end of array, element is not present.
		if prev == int(math.Min(float64(step), float64(size))) {
			return -1
		}
	}

	// Check if the element is found
	if arr[prev] == query {
		return prev
	}

	return -1
}
